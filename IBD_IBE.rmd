---
title: "IBD"
author: "Michelle DePrenger-Levin"
date: "November 17, 2016"
output: html_document
---

```{r}
rm(list=ls())
```

<http://rfunctions.blogspot.com/2016/10/simple-and-partial-mantel-tests.html>    
<http://dr-k-lo.blogspot.com/2012/04/how-to-do-mantel-test-in-r.html>     
<http://adegenet.r-forge.r-project.org/files/tutorial-basics.pdf>     

```{r}
library(raster)
library(rgdal)
library(maptools)
library(devtools)
library(ecodist)
library(vegan)
library(MASS)
library(prism)
library(dismo)
library(ggplot2)
library(Imap)
library(wordcloud)
library(MASS)
library(adegenet)
library(pegas)
library(ape)
library(ade4)
library(ggmap)
library(vegan)
library(boot)
library(ecodist)
library(geosphere)
library(poppr)



```

Tutorials
```{r, eval=FALSE}
adegenetTutorial("spca")
adegenetTutorial("dapc")

```

Pairwise distance matrix
```{r}
ph.dist <- read.csv("Q:/Research/Lab/Projects/Phacelia formosula/Project Information/Phacelia project information with GPS centroids 2016_pdm.csv")

#Convert the Northing/Easting to lat/long
ph.dist.UTM <- SpatialPoints(ph.dist[,c("Easting","Northing")],
                        proj4string = CRS("+proj=utm +zone=13 +datum=NAD83"))
ph.dist.LatLon <- spTransform(ph.dist.UTM, CRS("+proj=longlat +datum=WGS84"))
ph.dist <- data.frame(ph.dist,ph.dist.LatLon)

#These are just populations, not individuals
spatialdist.noTC <- dist(ph.dist[-15,3:4]) #exclude Troublesome Creek
spatialdist.TC <- dist(ph.dist[,3:4])
# from DAPC and <http://adegenet.r-forge.r-project.org/files/tutorial-basics.pdf>

#Dgeo <- spatialdist.noTC

ggmap(get_map(c(-107,40.25,-105.25,41)))+
  geom_point(data=ph.dist, aes(Easting.1,Northing.1))

```

spatial Analysis of principal components (sPCA) complements classical PCA retrieving non-trivial spatial genetic patterns   
Spatial and genetic data per individual -> don't want by individual Jan 26, 2018  
  - Thibaut in his vignette for adegenet says you can do isotlation by 
```{r}
# Genepop input file with PhGi (TC) 431 individuals
phall <- read.genepop("C:/Users/deprengm/Dropbox/Denver Botanic Gardens Postdoctoral Genetic Files/Phacelia project/Manuscript/GenAlExAnalyses_Nov2017/Genpop_PhfoData_Nov2017.gen")

table(phall@pop)
#Change to match T -> TC; F -> FC; B -> BR
currentlevels <- levels(phall@pop)
currentlevels[currentlevels=="T"] <- "TC"
currentlevels[currentlevels=="F"] <- "FC"
currentlevels[currentlevels=="B"] <- "BR"
levels(phall@pop) <- currentlevels

ph1 <- phall[phall@pop != "TC"] #395 individuals
table(ph1@pop)

#Can store spatial informaiton in @other$xy  
# Location information for each individual under Northing/Easting (need lat/lon) for individuals as $Code AN... and $Ind. 1:30 
phfo.gen <- read.csv("Q:/Research/Lab/Projects/Phacelia formosula/Project Information/Phacelia project information with GPS data 2016_all.csv")
nrow(phfo.gen) #451 - some individuals were thrown out for the genetic data. 
table(phfo.gen$Code)
#Still match these locaitons with the individuals from phall
table(phall@pop)

phfo.indloc <- read.csv("C:/Users/deprengm/Dropbox/Denver Botanic Gardens Postdoctoral Genetic Files/Phacelia project/Manuscript/GenAlExAnalyses_Nov2017/LatLon_PhfoData_Nov2017.csv")

table(phfo.indloc$SimpleCode)
curlev <- levels(phfo.indloc$SimpleCode)
curlev[curlev=="T"] <- "TC"
curlev[curlev=="F"] <- "FC"
curlev[curlev=="B"] <- "BR"
levels(phfo.indloc$SimpleCode) <- curlev


#Morphology  
phfo.loc <- read.csv("C:/Users/deprengm/Dropbox/Denver Botanic Gardens Postdoctoral Genetic Files/Phacelia project/Phacelia 2014 collection and morphology data/geoloc_ph.csv")
table(phfo.loc$Population.Code)


#phall are individuals from phfo.indloc
# So take the SimpleCode and IndNum from phfo.indloc and the Northing and Easting from phfo.gen matching Code and Ind.
phfo.UTM <- merge(phfo.gen,phfo.indloc[,c(1,3:4)],
                  by.x=c("Code","Ind."),by.y=c("SimpleCode","IndNum"))
table(phfo.UTM$Code)
sum(table(phfo.UTM$Code)) #425


#Convert phfo.UTM$Easting and $Northing to lat/lon
phfo.UTM.SP <- SpatialPoints(phfo.UTM[,c("Easting","Northing")],
                        proj4string = CRS("+proj=utm +zone=13 +datum=NAD83"))
phfo.LatLon <- spTransform(phfo.UTM.SP, CRS("+proj=longlat +datum=WGS84"))
phfo.UTM <- data.frame(phfo.UTM,phfo.LatLon)
names(phfo.UTM) <- c(names(phfo.UTM)[-c((length(phfo.UTM)-1):length(phfo.UTM))],"lon","lat")

#Want XY coordinates from phfo.gen that are individuals found in gen.ind
phall@other$xy <- phfo.UTM[,c("lon","lat")]
ph1@other$xy <- phfo.UTM[-grep("TC",phfo.UTM$Code),c("lon","lat")]
nrow(phall@other$xy) #425
```


```{r}
ggplot(phfo.UTM[phfo.UTM$Code != "TC",], aes(lon,lat,colour=Code, label=Code))+
  geom_point()+
  geom_text(hjust=1, size=3)+
  theme_bw()
```

Get distance matrix for genetic distance by population (15)
```{r}
Dgen <- dist.genpop(genind2genpop(phall), method=1) #1: Nei's 2: Angular Edward's Euclidean distance
Dgenind <- dist(phall@tab) #euclidean
Dgenind.maximum <- dist(phall@tab, method="max")
Dgeo <- dist(phall$other$xy)
#These are the genetic and geographic distance for 425 individuals
ibd <- mantel.randtest(Dgenind,Dgeo) #OH dear, Dgen is 15 populations, Dgeo are all individuals
ibd

plot(ibd)

ibdmax <- mantel.randtest(Dgeo,Dgenind.maximum)
ibdmax

#vegan version
vegan::mantel(Dgeo,Dgenind, permutations = 9999)
```

```{r}
plot(Dgeo,Dgenind)
abline(lm(Dgenind~Dgeo))

summary(lm(Dgenind~Dgeo))
```

```{r}
dens <-kde2d(Dgeo,Dgenind, n=300)
myPal <- colorRampPalette(c("white","blue","gold", "orange", "red"))
plot(Dgeo, Dgenind, pch=20,cex=.5)
image(dens, col=transp(myPal(300),.7), add=TRUE)
abline(lm(Dgenind~Dgeo))
title("Isolation by distance plot")
```

#Isolation by distance   
```{r}
## without TC Phacelia gina-glennea
Dgenind.noTC <- dist(ph1@tab) #euclidean
Dgenind.maximum.noTC <- dist(ph1@tab, method="max")
Dgeo.noTC <- dist(ph1$other$xy)
#These are the genetic and geographic distance for 425 individuals
ibd.noTC <- mantel.randtest(Dgenind.noTC,Dgeo.noTC) #OH dear, Dgen is 15 populations, Dgeo are all individuals
ibd.noTC

plot(ibd.noTC)

ibdmax <- mantel.randtest(Dgeo,Dgenind.maximum)
ibdmax

#vegan version
vegan::mantel(Dgeo,Dgenind, permutations = 9999)
# 1. Classical IBD would result in continuous clines of genetic differentiation 
# 2. distant and differentiated populations also results in this pattern. So...

#plot both distances
plot(Dgeo.tc,Dgen.tc)
abline(lm(Dgen.tc~Dgeo.tc), col="red",lty=2)

#Plot- can see patches
dens.tc <- kde2d(Dgeo.tc,Dgen.tc, n=300)
myPal <- colorRampPalette(c("white","blue","gold", "orange", "red"))
plot(Dgeo.tc, Dgen.tc, pch=20,cex=.5)
image(dens.tc, col=transp(myPal(300),.7), add=TRUE)
abline(lm(Dgen.tc~Dgeo.tc))
title("Isolation by distance plot")

plot(Dgeo.tc,Dgen.tc)

ph.dist

#Convert the Northing/Easting to lat/long
ptsutm <- SpatialPoints(phfo.gen[,c("Easting","Northing")],
                        proj4string = CRS("+proj=utm +zone=13 +datum=NAD83"))
ptsgeo <- spTransform(ptsutm, CRS("+proj=longlat +datum=WGS84"))

latlonphfo <- data.frame(phfo.gen,ptsgeo)

ggmap(get_map(c(-107,40.5,-105.5,41)))+
  geom_point(data=data, aes(long,lat,shape=Population.Code),size=4)+ #from Zapata_Phacelia.Rmd
  geom_point(data=latlonphfo, aes(Easting.1,Northing.1,colour=Population))
```

#Mantel test    
##2018.01.12_updates  
        - want to make PCA of soils and climate for distance matric of environment, compare to distance matrix of genetic    
ape
ade4

Isolation by distance (IBD) and Isolation by environment (IBE)
1) Mantel test
vegan - Forester et al 2016    
spatial eigenfunction analysis and multivariate linear regression (Diniz-Filho et al. 2013 and Legendre et al. 2015)  
i - PCoA to pairwise multivariate genetic distance matrix (Bray-Curtis)
ii - keep PCoA axes based on the broken-stick criterion (Legendre & Legendre 2012)   
iii - response data = kept axes, for redundancy analysis - mutivariate linear regression (RDA)
iv - predictors are spatial eigenfunctions (distance-based Moran's eigenvector maps, dbMEMs)
v - forward selection to reduce number of dbMEMs (Blanchet et al. 2008)
vi - calcuate r^2 assess signficantion using 1000 permutations   
<https://github.com/rforge/sedar/tree/master/pkg> 
both PCNM and packfor    
<http://dr-k-lo.blogspot.com/2012/04/how-to-do-mantel-test-in-r.html>     

<http://popgen.nescent.org/2015-05-18-Dist-SNP.html#section-2.-individual-genetic-distance-euclidean-distance-dist-adegenet> 


```{r}
plot(Dgeo,Dgenind)
abline(lm(Dgenind~Dgeo), col="red")

distgenEUCL <- dist(phall, method = "euclidean", diag = FALSE, upper = FALSE, p = 2)
hist(distgenEUCL)

# loci with at least one sample missing
phall.loci <- genind2loci(phall)
distgenDIFF <- dist.gene(phall.loci, method="pairwise", pairwise.deletion=FALSE, variance=FALSE)
hist(distgenDIFF)

op <- par(no.readonly = TRUE)
#Percent missing data per population
missing_data <- info_table(phall, type="missing")
sum(missing_data["Total",-13]>0) #10
barchart(missing_data["Total",-13], ylab="Locus", xlab="Percent Missing")
#stripchart(missing_data["Total",-13],method="jitter")
#rug(missing_data["Total",-13])
```
Keep loci even if one missing value
```{r}
distgenDIFF <- dist.gene(phall.loci, method="pairwise", pairwise.deletion = TRUE, variance = FALSE)
hist(distgenDIFF)

par(op)
```

Number of allelic differences between two individuals diss.dist from poppr    
```{r}
distgenDiSS <- diss.dist(phall, percent=FALSE, mat=FALSE)
hist(distgenDiSS)

```
Compare how different genetic distances deal with missing data and which might want to use in Mantel.test   
```{r}
phall.genepop <- genind2genpop(phall)
boxplot(distgenEUCL,distgenDIFF,distgenDiSS,dist.genpop(phall.genepop,method=2)) #the last is among populations, not individuals
```

Maybe not the euclidian one, Nei's is not. So the second one? 
```{r}
ibd.ind <- mantel.randtest(Dgeo, distgenDIFF)
ibd.ind
plot(ibd.ind)

```
Classical IBD means clines of genetic differentiation to cause a correlation, or distant and differentiated populations can also result in this pattern
```{r}
plot(Dgeo, distgenDIFF)
abline(lm(distgenDIFF~Dgeo), col="red", lty=2)

```
Visualize density 
```{r}
dens <- kde2d(Dgeo,distgenDIFF, n=300)
myPal <- colorRampPalette(c("white","blue","gold", "orange", "red"))
plot(Dgeo, distgenDIFF, pch=20,cex=.5)
image(dens, col=transp(myPal(300),.7), add=TRUE)
abline(lm(distgenDIFF~Dgeo))
title("Isolation by distance plot")

```


soils <https://www.nrcs.usda.gov/wps/portal/nrcs/detail/soils/survey/?cid=nrcs142p2_053627>
Data from USDA <http://websoilsurvey.nrcs.usda.gov/app/WebSoilSurvey.aspx>   
 1. Analsis Tools -> Overlay -> Spatial Join 2. In spatial join dialog box: -Target features = Points -Join features = Polygons -Join Operation = Join one to one -Right click on 'yield' field in join feature field map, select properties, choose 'Maximum' as merge rule -Match option = Intersect 
Try to get netCDF data for these points

Diniz-Filho et al 2013   
```{r, eval=FALSE}
options(prism.path = "Q:/Research/All_Projects_by_Species/Astragalus SPECIES/Astragalus_microcymbus/PRISM_asmiclimate")

#Precipitation total, rain and snow
get_prism_monthlys(type="ppt", mon = 1:12, keepZip = FALSE, years = 1980:1993)

#Maximum temperature (average)
get_prism_monthlys(type="tmax", mon = 1:12, keepZip = FALSE, years = 1980:1993)

#Minimum temperature (average)
get_prism_monthlys(type="tmin", mon = 1:12, keepZip = FALSE, years = 1980:1993)

```

```{r}
phall.genepop <- genind2genpop(phall)
boxplot(distgenEUCL,distgenDIFF,distgenDiSS,dist.genpop(phall.genepop,method=2)) #the last is among populations, not individuals
ibd.ind <- mantel.randtest(Dgeo, distgenDIFF)
ibd.ind
plot(ibd.ind)

plot(Dgeo, distgenDIFF)
abline(lm(distgenDIFF~Dgeo), col="red", lty=2)
```




```{r}
options(prism.path = "Q:/Research/All_Projects_by_Species/Astragalus SPECIES/Astragalus_microcymbus/PRISM_asmiclimate")

maxs <- grep("tmax", ls_prism_data(absPath=TRUE)[,2])
mins <- grep("tmin", ls_prism_data(absPath = TRUE)[,2])
ppt <- grep("ppt", ls_prism_data(absPath = TRUE)[,2])

avgTemps.max <- lapply(maxs, function(x){
  rastertemps <- raster(ls_prism_data(absPath=TRUE)[x,2])
  data.frame(data = extract(rastertemps, phfo.UTM[,c("lon","lat")]),              
             date = ls_prism_data()[x,])
})

avgTemps.min <- lapply(mins, function(x){
  rastertemps <- raster(ls_prism_data(absPath=TRUE)[x,2])
    data.frame(data = extract(rastertemps, phfo.UTM[,c("lon","lat")]), 
             date = ls_prism_data()[x,])
})

avgPrecip <- lapply(ppt, function(x){
  rastertemps <- raster(ls_prism_data(absPath=TRUE)[x,2])  
  data.frame(data = extract(rastertemps, phfo.UTM[,c("lon","lat")]), 
             date = ls_prism_data()[x,])
})
# These are the points, not the averages yet
mins.avg <- do.call(rbind, avgTemps.min)
maxs.avg <- do.call(rbind, avgTemps.max)
ppt.avg <- do.call(rbind, avgPrecip)

# also want the variance. so the SE of the averages


save(mins.avg, file="P:/hackathon/Phacelia/mins_avg.rda")
save(maxs.avg, file="P:/hackathon/Phacelia/maxs_avg.rda")
save(ppt.avg, file="P:/hackathon/Phacelia/ppt_avg.rda")


```

<https://cran.r-project.org/web/packages/dismo/vignettes/sdm.pdf>   
The code above returns a raster with the 18 bioclimate variables covering the whole world with a resoltion of 2.5 minutes of degrees:
averaged over 1960-1990

BIO1 = Annual Mean Temperature
BIO2 = Mean Diurnal Range (Mean of monthly (max temp â€“ min temp))
BIO3 = Isothermality (BIO2/BIO7) (* 100)
BIO4 = Temperature Seasonality (standard deviation *100)
BIO5 = Max Temperature of Warmest Month
BIO6 = Min Temperature of Coldest Month
BIO7 = Temperature Annual Range (BIO5-BIO6)
BIO8 = Mean Temperature of Wettest Quarter
BIO9 = Mean Temperature of Driest Quarter
BIO10 = Mean Temperature of Warmest Quarter
BIO11 = Mean Temperature of Coldest Quarter
BIO12 = Annual Precipitation
BIO13 = Precipitation of Wettest Month
BIO14 = Precipitation of Driest Month
BIO15 = Precipitation Seasonality (Coefficient of Variation)
BIO16 = Precipitation of Wettest Quarter
BIO17 = Precipitation of Driest Quarter
BIO18 = Precipitation of Warmest Quarter
BIO19 = Precipitation of Coldest Quarter

Bioclim data for Jackson, Larimer, and Grand counties
```{r}
bioclim.phfo <- getData("worldclim", var='bio', res = 0.5, lon = -106, lat = 41)

ggplot()+
  geom_path(data=ph.counties, aes(x=long, y=lat, group=group))+
  coord_map()+
  geom_point(data=phfo.UTM[,c("lon","lat")], aes(x=lon, y=lat))

#extract rasters to data
bio<-list()
for(i in 1:19){
  bio[[i]] <- extract(bioclim.phfo[[i]], phfo.UTM[,c("lon","lat")]) # projected from UTM Z13 NAD83 to longlat WGS84
}

#one matrix with bioclims and soils for presence points
pr.phfo <- do.call(cbind,bio)

usa <- getData("GADM", country="USA", level=2)
colorado <- usa[usa$NAME_1 == "Colorado",]
counties <- c("Larimer","Jackson","Grand")
ph.counties <- colorado[colorado$NAME_2 %in% grep(paste(counties, collapse="|"),
                                                 colorado$NAME_2, value=TRUE),]
ph.counties <- ph.counties[ph.counties$NAME_2 != "Rio Grande",]
 
plot(bioclim.phfo[[1]], xlim=c(-106.5,-105),ylim=c(40,41.125))
points(phfo.UTM[,c("lon","lat")], col=phfo.UTM$Code)
plot(ph.counties, add=TRUE)
```

Soils
```{r}
filenames <- list.files("Q:/Research/All_Projects_by_Species/aa_Shapefiles_Maps/Phacelia formosula/SoilLayers")
flnms <- unique(sapply(strsplit(filenames,"[.]"),'[',1)) #13 layers I have

shape <- list()
#Get all the soil layers I made
for(i in flnms){
  shape[[i]] <- readOGR("Q:/Research/All_Projects_by_Species/aa_Shapefiles_Maps/Phacelia formosula/SoilLayers", layer = paste(i))
}

#Dissolve polygons by type
aws <- do.call(rbind,lapply(which(flnms %in% flnms[grep("AWS",flnms)]), 
                                   function(x){
                                     shape[[x]]
                                     })) 

plot(aws)  

depthWT <- do.call(rbind,lapply(which(flnms %in% flnms[grep("depthWT",flnms)]), 
                                   function(x){
                                     shape[[x]]
                                     })) 

plot(depthWT) 

surfaceText <- do.call(rbind,lapply(which(flnms %in%
                                            flnms[grep("surfaceText",flnms)]), 
                                   function(x){
                                     shape[[x]]
                                     })) 

plot(surfaceText) 
points()


#Extract soil layers to points data
soil<-list()
for(i in length(shape)){
  soil[i] <- extract(shape[[i]], phfo.UTM[,c("lon","lat")])
}

#one matrix with bioclims and soils for presence points
pr.soil <- do.call(cbind,soil)


par(mfrow=c())

# get all soils and climate for each point


```

<https://cran.r-project.org/web/packages/dismo/vignettes/sdm.pdf>  
Overlap methods for background and presence points  Ward et al. 2009; Phillips and Elith, 2011  

```{r}
phfo.spdf <- SpatialPointsDataFrame(phfo.UTM[,c("lon","lat")],
                                    phfo.UTM)

# create background points for convex hull for all three
convH <- convHull(phfo.spdf)

# create background #2 with smaller circles around each county populations only   
# Need a grid to get one point per grid of size whatever bioclim is to get background points? 
x <- circles(phfo.UTM[,c("lon","lat")], d=10000, lonlat=TRUE) #10 km

#same grid as bioclim
#Make spatialpointsdataframe
background.mask <- mask(bioclim.phfo[[1]], polygons(x),
                        filename="Q:/Research/All_Projects_by_Species/Phacelia SPECIES/Phacelia_formosula/Phacelia formosula_abiotic/Maps/bc_mk_phfo_1")
bgd <- randomPoints(background.mask, 500)

plot(ph.counties)
plot(x, col=rgb(1,0.5,1,0.5), add=TRUE)
plot(convH, add=TRUE, col=rgb(0,0.5,1,0.5))
points(phfo.UTM[,c("lon","lat")], col="blue") 
plot(background.mask, add=TRUE)


#Need to download a larger AOI
plot(surfaceText)
points(phfo.UTM[,c("lon","lat")], col="red") 
points(bgd, col=rgb(0,0.5,1,0.5))

aws

# Save the circles and the convex hull as shapefile, break into 100^2 km chunkcs, feed into the soils usda site and get that coverage for phfo
xSPDF <- as(x@polygons, "SpatialPolygonsDataFrame")
writeOGR(xSPDF, layer="xCircles", dsn = "Q:/Research/All_Projects_by_Species/Phacelia SPECIES/Phacelia_formosula/Phacelia formosula_abiotic/Maps", driver="ESRI Shapefile")

convHSPDF <- as(convH@polygons, "SpatialPolygonsDataFrame")
writeOGR(convHSPDF, layer="xConvHull", dsn = "Q:/Research/All_Projects_by_Species/Phacelia SPECIES/Phacelia_formosula/Phacelia formosula_abiotic/Maps", driver="ESRI Shapefile")

disx <- disaggregate(x@polygons)
class(disx)
str(disx)

#cs <- c(3.65,3.65)*6000 #grid must be 100,000 acres: 1 acre = 4046.86 square meter; 1 degree latitude = 111.03 km | 68.99 miles and longitude = 1.42 km | 0.88 miles
#405km
405/111.03 #3.65


#cd <- ceiling(diff(t(bb))/cs) # number of cells per direction
#grd <- GridTopology(cellcentre.offset = bb[,1]+cs/2, cellsize = cs, cells.dim=cd)
#sp_grd <- SpatialGridDataFrame(grd,
#                               data=data.frame(id=1:prod(cd)),
#                               proj4string=CRS(proj4string(x@polygons)))
#plot(sp_grd)
```

```{r}
r <- raster()
bb <- bbox(x@polygons) #Spatial bounding box, sp::bbox

res(r) <- 3.65*15
r <- setExtent(r, bb)
r <- setValues(r,seq(1,r@ncols*r@nrows))
plot(r)
plot(ph.counties, add=TRUE)
points(phfo.UTM[,c("lon","lat")], col="red") 
points(bgd, col=rgb(0,0.5,1,0.5))

# need each grid as a shapefile
for(i in 1:(r@ncols*r@nrows)){
  r1 <- r
  r1[r1!=i] <- NA
  writeRaster(r1, paste("Q:/Research/All_Projects_by_Species/Phacelia SPECIES/Phacelia_formosula/Phacelia formosula_abiotic/Maps/phforas",i,".tif",
                        sep=""))
}


writeRaster(r, "Q:/Research/All_Projects_by_Species/Phacelia SPECIES/Phacelia_formosula/Phacelia formosula_abiotic/Maps/rastergrid.tif")
```

raster to shapefile
```{r}
#first not try that function above, just use the extent of the raster
for(i in 1:(r@ncols*r@nrows)){
  r1 <- r
  r1[r1!=i] <- NA
  r1 <- trim(r1, values=FALSE)
  p <- as(extent(r1), "SpatialPolygons")
  crs(p) <- proj4string(r)
  pSPDF <- as(p, "SpatialPolygonsDataFrame")
  writeOGR(pSPDF, layer=paste0("phfogrid",i),
            dsn = "Q:/Research/All_Projects_by_Species/Phacelia SPECIES/Phacelia_formosula/Phacelia formosula_abiotic/Maps", driver="ESRI Shapefile")

#  writeRaster(r1, paste("Q:/Research/All_Projects_by_Species/Phacelia SPECIES/Phacelia_formosula/Phacelia formosula_abiotic/Maps/phforas",i,".tif",sep=""))
}
```

```{r}
plot(ph.counties)
plot(x, col=rgb(1,0.5,1,0.5), add=TRUE)
plot(convH, add=TRUE, col=rgb(0,0.5,1,0.5))
points(phfo.UTM[,c("lon","lat")], col="blue") 
points(bgd)
```






```{r}

biodata <- data.frame(soils.unique,bio1.ph,bio19.ph,bio18.ph,
                      bio17.ph,bio16.ph,bio15.ph,bio14.ph,bio13.ph,bio12.ph,
                      bio11.ph,bio10.ph,bio9.ph,
                      bio8.ph,bio7.ph,bio6.ph,
                      bio5.ph,bio4.ph,bio3.ph,bio2.ph)
head(biodata)

# canberra meant for non-negative counts, out, but it does measure relative distance
# binary only for binary data, out
# Euclidean isn't great in high dimensions - squares the differences
# Manhattan just takes absolute value

#Should keep only not correltated ones
cor.table <- cor(biodata[,30:48])
data <- as.data.frame(as.table(cor.table))
combns <- combn(colnames(cor.table),2,FUN=function(x) paste(x,collapse = "_"))
cor.data <- data[data$Var1 != data$Var2, ]
data <- cor.data[paste(cor.data$Var1, cor.data$Var2, sep="_") %in% combns,]
head(data)

data[data$Var1 == "bio1.ph" & data$Freq > 0.7,]
data[data$Var2 == "bio1.ph"& data$Freq > 0.7,]
data[data$Freq > 0.7,]

# Keep only annual precipitation
data <- data[data$Var1 != "bio19.ph" & data$Var2 != "bio19.ph",]
data <- data[data$Var1 != "bio18.ph" & data$Var2 != "bio18.ph",]
data <- data[data$Var1 != "bio17.ph" & data$Var2 != "bio17.ph",]
data <- data[data$Var1 != "bio16.ph" & data$Var2 != "bio16.ph",]
data <- data[data$Var1 != "bio15.ph" & data$Var2 != "bio15.ph",]
data <- data[data$Var1 != "bio14.ph" & data$Var2 != "bio14.ph",]
data <- data[data$Var1 != "bio13.ph" & data$Var2 != "bio13.ph",]

# If keep bio12: get rid of bio3 (Isothermality), keep annual mean temp (1)
data <- data[data$Var1 != "bio3.ph" & data$Var2 != "bio3.ph",]
data <- data[data$Var1 != "bio10.ph" & data$Var2 != "bio10.ph",]
data <- data[data$Var1 != "bio8.ph" & data$Var2 != "bio8.ph",]

# Keep bio2: mean diurnal range, get rid of 4,5,and 7
data <- data[data$Var1 != "bio4.ph" & data$Var2 != "bio4.ph",]
data <- data[data$Var1 != "bio5.ph" & data$Var2 != "bio5.ph",]
data <- data[data$Var1 != "bio7.ph" & data$Var2 != "bio7.ph",]

#Either keep min temp of coldest month (6) or quarter (11)
data <- data[data$Var1 != "bio11.ph" & data$Var2 != "bio11.ph",]

names(biodata[,c(30,38,41,44,48)])
pairs(biodata[,c(30,38,41,44,48)])

bio.dist <- dist(biodata[,c(30,38,41,44,48)], method="manhattan") 

bio.prcomp <- prcomp(biodata[,c(30,38,41,44,48)], center = TRUE)
print(bio.prcomp)
summary(bio.prcomp)

plot.bio <- data.frame(biodata,bio.prcomp$x)

populations <- unique(plot.bio$Population)
plot.bio$Species <- "phsc"
plot.bio$Species[plot.bio$Population %in% paste(populations[c(1:3,5:7,11:15)],sep="|")] <- "phfo"
plot.bio$Species[plot.bio$Population == populations[4]] <- "phgi"


ggplot(plot.bio, aes(PC1,PC2, colour=Population))+
  geom_point()+
  theme_bw()


ggplot(plot.bio, aes(PC1,PC2, colour=Species))+
  geom_point()+
  theme_bw()

## try with princomp
bionames <- names(biodata[,c(30,38,41,44,48)])

pairs(biodata[,c(30,38,41,44,48)])
keep <- c(30,38,41,44,48)
      
ph.pca <- princomp(biodata[,keep], cor=TRUE)
summary(ph.pca)
asmi.load <- loadings(ph.pca) #1: Annual Mean Temperature, 11: Mean temp of coldest quarter, 9: Mean temp of driest quarter


plot.pca <- data.frame(ph.pca$scores, plot.bio)

ggplot(plot.pca, aes(Comp.1,Comp.2,colour = Species))+
  geom_point()+
  theme_bw()

ggplot(plot.bio, aes(bio6.ph, bio2.ph, colour = Species))+
  geom_point()+
  labs(x = "Min Temperature of Coldest Month", 
       y = "Mean Diurnal Range (Mean of monthly (max temp - min temp))")+
#  geom_polygon(aes(fill = Species), alpha = 0.3)+
  theme_bw()


ggplot(plot.bio, aes(bio1.ph, bio9.ph, colour = Species))+
  geom_point()+
  labs(x = "Annual mean temperature", y = "Mean temperature of driest quarter")+
  theme_bw()

ggplot(plot.bio, aes(bio1.ph, bio12.ph, colour = Species))+
  geom_point()+
  labs(x = "Annual mean temperature", y = "Annual Precipitation")+
  theme_bw()


# summer and winter moisture... 
ggplot(plot.bio, aes(bio18.ph, bio19.ph, colour = Species))+
  geom_point()+
  theme_bw()


ggplot(plot.bio, aes(bio11.ph, bio9.ph, colour = Species))+
  geom_point()+
  labs(x = "Mean temperature of coldest quarter", y = "Mean temperature of driest quarter")+
  theme_bw()

ggplot(plot.bio, aes(bio11.ph, bio9.ph, colour = Species))+
  geom_point()+
  labs(x = "Mean temperature of coldest quarter", y = "Mean temperature of driest quarter")+
  theme_bw()

ggplot(plot.bio, aes(bio14.ph, bio19.ph, colour = Species))+
  geom_point()+
  labs(x = "Precipitation of Driest Month", y = "Precipitation of Coldest Quarter")+
  theme_bw()

ggplot(plot.bio, aes(bio6.ph, bio19.ph, colour = Species))+
  geom_point()+
  labs(x = "Min Temperature of Coldest Month", y = "Precipitation of Coldest Quarter")+
  theme_bw()

unique(plot.bio$MUSYM)
unique(plot.bio$MUKIND)
unique(plot.bio$MUKEY)

ggplot(plot.bio, aes(MUSYM, bio12.ph, colour = Species))+
  geom_violin()+
  geom_point()+
  labs(x= "Soil Type", y = "Annual Precipitation")+
  theme_bw()


#Which are correlated? 
data[abs(data$Freq)>0.75,]

# Use daisy to combine bioclim and soil

```


### TO DO:
<http://creativemorphometrics.co.vu/blog/2014/03/27/extracting-climate-data-in-r/>    
get data   
```{r}
setwd("~/tmean") #this is the folder with all the GeoTiffs
library(raster)
library(sp)
library(rgdal)
meanJan <- raster("tmean1_16.tif") #mean temp for January etc.
meanFeb <- raster("tmean2_16.tif")
meanMar <- raster("tmean3_16.tif")
meanApr <- raster("tmean4_16.tif")
meanMaj <- raster("tmean5_16.tif")
meanJun <- raster("tmean6_16.tif")
meanJul <- raster("tmean7_16.tif")
meanAvg <- raster("tmean8_16.tif")
meanSep <- raster("tmean9_16.tif")
meanOkt <- raster("tmean10_16.tif")
meanNov <- raster("tmean11_16.tif")
meanDec <- raster("tmean12_16.tif")
plot(meanJan) #will simply get the basic R plot of a GeoTiff raster




```


<http://www.sthda.com/english/wiki/ade4-and-factoextra-principal-component-analysis-r-software-and-data-mining>

Data cleaning
```{r}
sum(duplicated(soils[,c("EastingAll","NorthingAll")]))
#28

soils.unique <- soils[!duplicated(soils[,c("EastingAll","NorthingAll")]),]
ph.points <- spTransform(SpatialPoints(cbind(soils.unique$EastingAll,soils.unique$NorthingAll),
                                       proj4string = CRS("+proj=utm +zone=13 +datum=NAD83")),
                         CRS("+proj=longlat +datum=WGS84"))

#cross check coordinates
#Make a SpatialPointsDataFrame
library(sp)

ph.p <-data.frame(coordinates(ph.points))

ggplot()+
  geom_path(data=ph.counties, aes(x=long, y=lat, group=group))+
  coord_map()+
  geom_point(data=ph.p, aes(x=coords.x1, y=coords.x2))


```

Sampling bias    
with many samples, subsampling to reduce sampling bias   
ph.points == acg in example
```{r}
r <- raster(ph.points)
#cells are set to 1 degree
res(r) <- 1
# extend the extent of the RasterLayer a little
r <- extend(r, extent(r)+1)
#sample
phsel <- gridSample(ph.points, r, n=1) # must be 1 per degree cell

p <- rasterToPolygons(r)
plot(p, border='gray')
points(ph.points)
```

Background data - for when you don't have absence data   
OR pseudo-absences but these guys don't like as much
dismo to sample random points for background data
```{r}

files <- list.files(path=paste(system.file(package="dismo"), '/ex',
                               sep=''), pattern='grd', full.names=TRUE )

#mask to exclude areas with no data
mask <- raster(files[1])

#select random sample points, set seed
set.seed(1963)
bg <- randomPoints(mask, 500)

plot(!is.na(mask), legend=FALSE)
points(bg, cex=0.5)

#extent to restrict areas from which random points will be drawn
e <- extent(-80, -53, -39, -22)
bg2 <- randomPoints(mask, 50, ext=e)
plot(!is.na(mask), legend=FALSE)
plot(e, add=TRUE, col='red')
points(bg2, cex=0.5)


#Phacelia
rm(mask,bg2,rr)
mask <- raster(xmn=-107, xmx=-105,ymn=40, ymx = 41, nrow=100, ncol=100)
mask[]=runif(100*100)

plot(mask)
plot(ph.counties, add=TRUE)
points(ph.points)

rr <- mask(mask,ph.counties)

plot(rr)
plot(ph.counties, add=TRUE)

bg2 <- randomPoints(rr, 500)
plot(!is.na(mask), legend=FALSE)
plot(rr, add=TRUE, col='red')
points(bg2, cex=0.5)

#circles with a radius of 5 km
x <- circles(rasterToPoints(rr), d=5000, lonlat=TRUE)
pol <- polygons(x)

head(x@presence)
head(x@absence)

# then use rgeos package to dissolve circles (remove boundaries where overlap)
#sample from circles
samp1 <- spsample(pol, 250, type="random", iter=25)
cells <- cellFromXY(mask, samp1)
cells <- unique(cells)

xy <- xyFromCell(mask, cells)

plot(pol, axes=TRUE)
points(xy, cex=0.75, pch=20, col='blue')
```

Raster data - predictor variables    
ASCII files are slow
```{r}
#get elevation from worldclim
w <- getData('alt', country='USA')

files <- list.files(path=paste("Q:/Research/All_Projects_by_Species/aa_Shapefiles_Maps/aa_GENERAL_non-species_files/All_General_Background_Layers/World BioClim Date/bio_2-5m_bil", 
                               sep = ''),
                    pattern='grd', full.names=TRUE)

files2 <- list.files(path=paste("Q:/Research/All_Projects_by_Species/aa_Shapefiles_Maps/aa_GENERAL_non-species_files/All_General_Background_Layers/World BioClim Date",
                                sep = ''),
                     pattern='grd', full.names=TRUE)

usa.alt <- raster("Q:/Research/All_Projects_by_Species/aa_Shapefiles_Maps/aa_GENERAL_non-species_files/All_General_Background_Layers/World BioClim Date/USA1_msk_alt.grd")

m <- data.frame(long = c(max(ph.points@coords[,1]),min(ph.points@coords[,1])),
                lat = c(max(ph.points@coords[,2]),min(ph.points@coords[,2])))
cbind(m, alt = extract(w, m))

# Don't know what the .grd.vat.cpg files are
predictors <- stack(files[c(1,4:21)])

#missing projection
proj4string(predictors) <- CRS("+proj=longlat +datum=WGS84")
proj4string(usa.alt) <- CRS("+proj=longlat +datum=WGS84")

names(predictors)
plot(predictors)
plot(usa.alt)

predictors <- crop(predictors, extent(r)+1)
predictor.alt <- crop(files2)

plot(predictors)

plot(predictors,1)
plot(ph.counties, add=TRUE)
points(ph.points, col="blue", pch =20, cex = 0.5)

```

Create new predictor variables - example: use land cover data and focal() and create new variable that indicates how much forest area is available within Xkm of a grid cell..
```{r}
?focal

```

#Extract values from rasters
```{r}
presvals <- extract(predictors, ph.points)
altvals <- extract(usa.alt, ph.points)

cnts <- extract(ph.counties, ph.points)

#set random seed to always create same random set of points
set.seed(0)

backgr <- randomPoints(predictors, 500)

absvals <- extract(predictors, backgr)

# row for each point 
pb <- c(rep(1, nrow(presvals)), rep(0, nrow(absvals)))
cnts <- c(cnts$NAME_2, rep(0, nrow(absvals)))
site <- c(soils.unique$Population, rep(0, nrow(absvals)))
sdmdata <- data.frame(cnts, site, pb, rbind(presvals, absvals))

#categorical variables   
#SKIP
sdmdata[,'biome'] <- as.factor(sdmdata[,'biome'])

head(sdmdata)
table(sdmdata$cnts)

pairs(sdmdata[,4:22], cex=0.1, fig=TRUE)

#sdmdata[,3:22] <- sapply(sdmdata[,3:22], function(num) as.numeric(num))
```

#Model fitting   
pb - presence vs background points for the three phacelia species
```{r}
m1 <- glm(pb ~ bio1 + bio13 + bio2 + bio3 + bio4 + bio9, data=sdmdata)
class(m1)

summary(m1)

bc <- bioclim(presvals[,c('bio1','bio13','bio2','bio3','bio4','bio9')])
class(bc)
pairs(bc)
```

#Model evaluation
```{r}
#training data set
samp <- sample(nrow(sdmdata), round(0.75 * nrow(sdmdata)))
traindata <- sdmdata[samp,]

traindata <- traindata[traindata[,'pb'] == 1, -(1:3)]

testdata <- sdmdata[-samp,]
bc <- bioclim(traindata)

e <- evaluate(testdata[testdata$pb==1,], testdata[testdata$pb==0,], bc)
plot(e, 'ROC')

#Really want a k-fold data partitioning instead of single random sample
#### START HERE on page 39 of the sdm vignette

```



```{r}
#too many, take out highly correlated ones
cutoff <- 0.75
cor.table <- cor(sdmdata[,-(1:3)])
data <- as.data.frame(as.table(cor.table))
combins <- combn(colnames(cor.table),2,FUN=function(x) paste(x,collapse="_"))
cor.data <- data[data$Var1 != data$Var2, ]
data <- cor.data[paste(cor.data$Var1, cor.data$Var2, sep="_") %in% combins,]
exclude1 <- paste(data$Var2[abs(data$Freq)>cutoff],sep=",")
exclude2 <- paste(data$Var1[abs(data$Freq)>cutoff],sep=",")


#Which are correlated? 
data.cor <- data[abs(data$Freq)>cutoff,]
correlated <- c(grep(paste(c(exclude1,exclude2), collapse="|"),names(sdmdata), value=TRUE))

pairs(sdmdata[,correlated], cex=0.1, fig=TRUE)

forstep <- sdmdata[,c(grep(paste(exclude1, collapse="|"),
                            names(sdmdata), value=TRUE, invert=TRUE))]

pairs(forstep[,-(1:3)])

pairs(sdmdata[,c(unique(exclude2),unique(exclude1))])
```

Step regression - which factors explain differences in species   
convergence issues: logistf <http://cran.r-project.org/web/packages/logistf/logistf.pdf>
```{r}
glm(cnts~bio1+bio13+bio13+bio2+bio3+bio4+bio9,
    data=forstep[cnts!="0",], family = binomial, control = list(maxit=50))

step1 <- step(glm(cnts~bio1+bio13+bio13+bio2+bio3+bio4+bio9,
                 data=forstep, family=binomial),control = list(maxit=70))

#Don't need the background points for these
ggplot(sdmdata[cnts!="0",], aes(x=cnts, y=bio2))+
  geom_boxplot()

# 3 same for Larimer and Grand
ggplot(sdmdata[cnts!="0",], aes(bio1,bio4,colour=cnts))+ 
  geom_point()

#15 splits Jackson
ggplot(sdmdata[cnts!="0",], aes(bio1,bio3,colour=cnts))+ 
  geom_point()

ggplot(sdmdata[cnts!="0",], aes(bio1,bio2,colour=cnts))+ 
  geom_point()

ggplot(sdmdata[cnts!="0",], aes(bio1,bio13,colour=cnts))+ 
  geom_point()

ggplot(sdmdata[cnts!="0",], aes(bio1,bio9,colour=cnts))+ 
  geom_point()


```

Environmental factors and background points
```{r}
ggplot(sdmdata, aes(x=cnts, y=bio15))+
  geom_boxplot()

ggplot(sdmdata, aes(x=cnts, y=bio1))+
  geom_boxplot()

ggplot(sdmdata, aes(x=cnts, y=bio2))+
  geom_boxplot()

ggplot(sdmdata, aes(x=cnts, y=bio13))+
  geom_boxplot()

ggplot(sdmdata, aes(x=cnts, y=bio9))+
  geom_boxplot()



```



#Ignore Grand
```{r}
sdmdata.phfo.phsc <- sdmdata[cnts=="Jackson"|cnts=="Larimer",]
sdmdata.phfo.phsc$cnts <- factor(sdmdata.phfo.phsc$cnts)

step1 <- step(glm(cnts~bio10+bio13+bio15+bio18+bio2+bio8,
                 data=sdmdata.phfo.phsc, family=binomial),control = list(maxit=70))

ggplot(sdmdata.phfo.phsc, aes(bio2, bio18, colour=cnts))+
  geom_point()+
  stat_ellipse()

ggplot(sdmdata.phfo.phsc, aes(bio6, bio14, colour=cnts))+
  geom_point()

```




<https://www.rforge.net/doc/packages/climates/html/bioclim.html>
```{r}
install.packages("climates") #nope, how?!


```


Now have environmental variables (by going through the sdm vignette)
follow vegan tutorial, trying to get environmental variables   
<http://cc.oulu.fi/~jarioksa/opetus/metodi/vegantutor.pdf>
```{r}


```


ecodist   
simple mantel statistic  - degree of dissimilarity in one datset compared to detree of dissimilarity in another independently-derived dataset   
<https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3873175/>   
<http://www.molecularecologist.com/2015/06/ibeibd-contour-plots-in-r/>  

Forester et al. 2016 Molecular Ecology 
##### START HERE #####
1) PCA 
2) RDA reduncancy analysis : contrained ordination extends linear regression to multivariate response data to maximize proportion of response variable that is explained. (response variables: genetic data; linear comintation of predictor variables (environemtnal data)) 
```{r}
library(labdsv)
vegdist()

ph.df <- genind2df(ph1)
head(ph.df)
ph.df <- as.data.frame(ph.df)
ph.df[,2:13] <- sapply(ph.df[,2:13], function(x) as.numeric(x))

ph.vegdist <- vegdist(ph.df[,-1], method = "bray", na.rm = TRUE)
disana(ph.vegdist)

ph.pco <- pco(ph.vegdist)
ph.pco$eig

barplot(ph.pco$eig)

ph.genepop <- genind2genpop(ph1)
tab(ph.genepop)
```

<http://adegenet.r-forge.r-project.org/files/tutorial-basics.pdf>  
Some of this would work better for the environmental variables
```{r}
ph.tab <- tab(ph.genepop, NA.method="mean")
ph.pca <- dudi.pca(ph.tab, scannf=TRUE, scale=FALSE) # nf = 4  #can determine number dimensions in the final results

summary(ph.pca)
phxy <- ph.pca$co
   
s.corcircle(phxy, label = row.names(phxy), grid = TRUE,
            box = FALSE)

temp <- as.integer(pop(ph1))
myCol <- transp(c("red","blue"),.7)[temp]
myPch <- c(15:17)[temp]

plot(ph.pca$li)
plot(ph.pca$li, col = myCol, pch=myPch) 

## use wordcloud for non-overlapping labels
textplot(ph.pca$li[,1], ph.pca$li[,2], words=rownames(ph.tab), cex=1.4, new=FALSE)

## legend the axes by adding loadings
#abline(h=0,v=0,col="grey",lty=2)
#s.arrow(ph.pca$c1*.5, add.plot=TRUE)
legend("topright", pch=c(15,17), col=transp(c("blue","red"),.7),
leg=c("Group A","Group B"), pt.cex=2)

#https://trapa.cz/sites/default/files/r_mol_data_phylogen.pdf
# Kernel density
s.label(ph.pca$li, clabel = 0.75)
s.kde2d(ph.pca$li, cpoint=0, add.plot = TRUE)

```

Pluess et al 20016 New Phytologist
```{r}
#Variable factor map
pca.space <- princomp(pca.ph[,-(1:3)], cor=TRUE)
summary(pca.space)
ph.load <- loadings(pca.space)
ph.pc <- predict(pca.space)

ph.pc <- data.frame(ph.pc, pca.ph)

summary(lm(Comp.1~alt, data=ph.pc))

rm(ph.pc)
#PCA of factors
pca.ph <- sdmdata[cnts!="0",]
pca.ph$alt <- altvals

cutoff <- 0.75
cor.table <- cor(pca.ph[,-(1:3)])
data <- as.data.frame(as.table(cor.table))
combins <- combn(colnames(cor.table),2,FUN=function(x) paste(x,collapse="_"))
cor.data <- data[data$Var1 != data$Var2, ]
data <- cor.data[paste(cor.data$Var1, cor.data$Var2, sep="_") %in% combins,]
exclude1 <- paste(data$Var2[abs(data$Freq)>cutoff],sep=",")
exclude2 <- paste(data$Var1[abs(data$Freq)>cutoff],sep=",")


#Which are correlated? 
data.cor <- data[abs(data$Freq)>cutoff,]
correlated <- c(grep(paste(c(exclude1,exclude2), collapse="|"),names(pca.ph), value=TRUE))

pairs(pca.ph[,correlated[1:5]], cex=0.1, fig=TRUE)
pairs(pca.ph[,correlated[6:10]], cex=0.1, fig=TRUE)

forpca <- pca.ph[,c(grep(paste(exclude1, collapse="|"),
                         names(pca.ph), value=TRUE, invert=TRUE))]



ph.pca <- princomp(forpca[,-(1:3)], cor=TRUE)
summary(ph.pca)
ph.load <- loadings(ph.pca)
ph.pc <- predict(ph.pca)

ph.pc <- data.frame(ph.pc, pca.ph)

summary(lm(Comp.1~alt, data=ph.pc))
```


```{r}
ggplot(ph.pc, aes(Comp.1, Comp.2, colour = cnts))+
  geom_point()+
  stat_ellipse()

```


redundancy analysis (RDA): combines PCA on allele frequencies and multiple regression
Meirmans Molecular Ecology "Seven common mistakes in pouplaiton genetics and how to avoid them"


<https://www.analyticsvidhya.com/blog/2016/04/complete-tutorial-tree-based-modeling-scratch-in-python/> 
```{r}


```
