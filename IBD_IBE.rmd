---
title: "IBD"
author: "Michelle DePrenger-Levin"
date: "November 17, 2016"
output: html_document
---

```{r}
rm(list=ls())
```

<http://rfunctions.blogspot.com/2016/10/simple-and-partial-mantel-tests.html>    
<http://dr-k-lo.blogspot.com/2012/04/how-to-do-mantel-test-in-r.html>     
<http://adegenet.r-forge.r-project.org/files/tutorial-basics.pdf>     

```{r}
library(raster)
library(rgdal)
library(maptools)
library(devtools)
library(ecodist)
library(vegan)
library(MASS)
library(prism)
library(dismo)
library(ggplot2)
library(Imap)
library(wordcloud)
library(MASS)
library(adegenet)
library(pegas)
library(ape)
library(ade4)
library(ggmap)
library(vegan)
#install.packages("PCNM") # not avaliable for 3.3.1, a funciton in vegan?
library(boot)
#install_git("rforge/sedar/pkg/AEM")
#install_github("rforge/sedar/pkg/PCNM")
library(ecodist)
library(geosphere)
library(poppr)



```

Tutorials
```{r}
adegenetTutorial("spca")
adegenetTutorial("dapc")

```

Pairwise distance matrix
```{r}
ph.dist <- read.csv("Q:/Research/Lab/Projects/Phacelia formosula/Project Information/Phacelia project information with GPS centroids 2016_pdm.csv")

#Convert the Northing/Easting to lat/long
ph.dist.UTM <- SpatialPoints(ph.dist[,c("Easting","Northing")],
                        proj4string = CRS("+proj=utm +zone=13 +datum=NAD83"))
ph.dist.LatLon <- spTransform(ph.dist.UTM, CRS("+proj=longlat +datum=WGS84"))
ph.dist <- data.frame(ph.dist,ph.dist.LatLon)

#These are just populations, not individuals
spatialdist.noTC <- dist(ph.dist[-15,3:4]) #exclude Troublesome Creek
spatialdist.TC <- dist(ph.dist[,3:4])
# from DAPC and <http://adegenet.r-forge.r-project.org/files/tutorial-basics.pdf>

#Dgeo <- spatialdist.noTC

ggmap(get_map(c(-107,40.25,-105.25,41)))+
  geom_point(data=ph.dist, aes(Easting.1,Northing.1))

```

spatial Analysis of principal components (sPCA) complements classical PCA retrieving non-trivial spatial genetic patterns   
Spatial and genetic data per individual -> don't want by individual Jan 26, 2018  
  - Thibaut in his vignette for adegenet says you can do isotlation by 
```{r}
# Genepop input file with PhGi (TC) 431 individuals
#phall <- read.genepop("C:/Users/deprengm/Dropbox/Denver Botanic Gardens Postdoctoral Genetic Files/Phacelia project/Riser/Genepop/PhfoAllGenePop_13Dec2016.gen")
phall <- read.genepop("C:/Users/deprengm/Dropbox/Denver Botanic Gardens Postdoctoral Genetic Files/Phacelia project/Manuscript/GenAlExAnalyses_Nov2017/Genpop_PhfoData_Nov2017.gen")


ph1 <- phall[popNames(phall) != "T"] #403 individuals

#Which individuals were kept? From NAME formated as HN-01...
gen.ind <- read.csv("C:/Users/deprengm/Dropbox/Denver Botanic Gardens Postdoctoral Genetic Files/Phacelia project/Phacelia microsatellite data/GenAlEx/Phfo_GENALEX truncated data_12-18-2014_reformat_medl.csv")

sum(table(gen.ind$Population)) #431 individuals
nrow(ph1@tab) #403 (without TC)
nrow(phall@tab) #431 

#Can store spatial informaiton in @other$xy  
# Location information for each individual under Northing/Easting (need lat/lon) for individuals as $Code AN... and $Ind. 1:30 
phfo.gen <- read.csv("Q:/Research/Lab/Projects/Phacelia formosula/Project Information/Phacelia project information with GPS data 2016_all.csv")
nrow(phfo.gen) #451 - some individuals were thrown out for the genetic data. 
head(gen.ind) #need code as HN-01 and so on

#Ha ha! get all the individuals into a two digit string
formatC(phfo.gen$Ind., width=2, flag="0")

#Do the codes from gen.ind and phall match? Nope. gen.ind$NAME is a factor
table(sapply(as.character(gen.ind$NAME), function(code){
  unlist(strsplit(code, "-"))[1]
  }))
table(phfo.gen$Code)

gen.ind$NAME <- as.character(gen.ind$NAME)
gen.ind$NAME <- gsub("B","BR",gen.ind$NAME)
gen.ind$NAME <- gsub("F","FC",gen.ind$NAME)
gen.ind$NAME <- gsub("T","TC",gen.ind$NAME)

#Make $NAME match for both tables
phfo.gen$NAME <- paste(phfo.gen$Code,"-",formatC(phfo.gen$Ind., width=2, flag="0"),
                       sep="")

#Convert phfo.gen$Easting and $Northing to lat/lon
phfo.gen.UTM <- SpatialPoints(phfo.gen[,c("Easting","Northing")],
                        proj4string = CRS("+proj=utm +zone=13 +datum=NAD83"))
phfo.gen.LatLon <- spTransform(phfo.gen.UTM, CRS("+proj=longlat +datum=WGS84"))
phfo.gen <- data.frame(phfo.gen,phfo.gen.LatLon)
names(phfo.gen) <- c(names(phfo.gen)[-c((length(phfo.gen)-1):length(phfo.gen))],"lon","lat")

#Want XY coordinates from phfo.gen that are individuals found in gen.ind
include.ind <- merge(phfo.gen,gen.ind, by="NAME") #431
phall@other$xy <- include.ind[,c("lon","lat")]
ph1@other$xy <- include.ind[-grep("TC",include.ind$NAME),c("lon","lat")]
nrow(include.ind[-grep("TC",include.ind$NAME),c("lon","lat")]) #401?! Should be 403 to match ph1, 2 individuals are funny! Troublesome Creek has some odd notes about spilling and x2 viles
```

Get distance matrix for genetic distance by population (15)
```{r}
Dgen <- dist.genpop(genind2genpop(phall), method=1) #1: Nei's 2: Angular Edward's Euclidean distance
Dgenind <- dist(phall@tab) #euclidean
Dgenind.maximum <- dist(phall@tab, method="max")
Dgeo <- dist(phall$other$xy)
#These are the genetic and geographic distance for 431 individuals
ibd <- mantel.randtest(Dgenind,Dgeo) #OH dear, Dgen is 15 populations, Dgeo are all individuals
ibd

plot(ibd)

ibdmax <- mantel.randtest(Dgeo,Dgenind.maximum)
ibdmax

#vegan version
vegan::mantel(Dgeo,Dgenind, permutations = 9999)
```

```{r}
plot(Dgeo,Dgenind)
abline(lm(Dgenind~Dgeo))

summary(lm(Dgenind~Dgeo))
```
```{r}
dens <-kde2d(Dgeo,Dgenind, n=300)
myPal <- colorRampPalette(c("white","blue","gold", "orange", "red"))
plot(Dgeo, Dgenind, pch=20,cex=.5)
image(dens, col=transp(myPal(300),.7), add=TRUE)
abline(lm(Dgenind~Dgeo))
title("Isolation by distance plot")
```

#Isolation by distance   
Can be by individual or by populaiton. I have an issue with matching the individuals with their locations. 431 individuals with genetic data and locations. When I try to remove TC I get 401 individuals but should be 395 indiviudals without TC???
```{r}
dens <- kde2d(Dgeo,Dgen, n = 300)
myPal <- colorRampPalette(c("white","blue","gold", "orange", "red"))
plot(Dgeo, Dgen, pch=20,cex=.5)
image(dens, col=transp(myPal(300),.7), add=TRUE)
abline(lm(Dgen~Dgeo))
title("Isolation by distance plot")


## with TC Phacelia gina-glennea
Dgen.tc <- dist.genpop(phall.genepop, method=2)
Dgeo.tc <- spatialdist.TC
ibd.tc <- mantel.randtest(Dgen.tc,Dgeo.tc)
plot(ibd.tc) # Isolation by distance is signficant

# 1. Classical IBD would result in continuous clines of genetic differentiation 
# 2. distant and differentiated populations also results in this pattern. So...

#plot both distances
plot(Dgeo.tc,Dgen.tc)
abline(lm(Dgen.tc~Dgeo.tc), col="red",lty=2)

#Plot- can see patches
dens.tc <- kde2d(Dgeo.tc,Dgen.tc, n=300)
myPal <- colorRampPalette(c("white","blue","gold", "orange", "red"))
plot(Dgeo.tc, Dgen.tc, pch=20,cex=.5)
image(dens.tc, col=transp(myPal(300),.7), add=TRUE)
abline(lm(Dgen.tc~Dgeo.tc))
title("Isolation by distance plot")

plot(Dgeo.tc,Dgen.tc)

ph.dist

#Convert the Northing/Easting to lat/long
ptsutm <- SpatialPoints(phfo.gen[,c("Easting","Northing")],
                        proj4string = CRS("+proj=utm +zone=13 +datum=NAD83"))
ptsgeo <- spTransform(ptsutm, CRS("+proj=longlat +datum=WGS84"))

latlonphfo <- data.frame(phfo.gen,ptsgeo)

ggmap(get_map(c(-107,40.5,-105.5,41)))+
  geom_point(data=data, aes(long,lat,shape=Population.Code),size=4)+ #from Zapata_Phacelia.Rmd
  geom_point(data=latlonphfo, aes(Easting.1,Northing.1,colour=Population))
```

```{r}  
## example from adegenet - genind object iwth a matrix of xy coordinates
#### Monmonierâs algorithm to define genetic boundaries
temp <- as.integer(ph1$pop)

#temp <- as.numeric(as.character(temp))
plot(ph1$other$xy,pch=temp,cex=1.5,xlab='x',ylab='y') #guess it's ok the numbers don't match?
legend("bottomright",leg=unique(ph1$pop),pch=unique(as.numeric(ph1$pop))) #this is not right

```

#convert Northing Easting to lat long
```{r}
#Just the 15 populaitons, not individuals
ph.ll <- spTransform(SpatialPoints(cbind(ph.dist$Easting,ph.dist$Northing),
                          proj4string = CRS("+proj=utm +zone=13 + datus=NAD83")),
            CRS("+proj=longlat +datum=WGS84"))

ph.lls <- data.frame(coordinates(ph.ll))

#give geode
pairdist <- lapply(2:nrow(ph.lls), function(x){
  gdist(lat.1=ph.lls$coords.x2[x-1], lon.1 = ph.lls$coords.x1[x-1], 
        lat.2=ph.lls$coords.x2[x], lon.2 = ph.lls$coords.x1[x], units = "m")
})


ph.dist.eu <- dist(ph.lls)

#write.table(ph.dist.eu, "clipboard", sep="\t", row.names=FALSE, col.names = FALSE)

```


#Mantel test    
##2018.01.12_updates  
        - want to make PCA of soils and climate for distance matric of environment, compare to distance matrix of genetic    
ape
ade4

Isolation by distance (IBD) and Isolation by environment (IBE)
1) Mantel test
vegan - Forester et al 2016    
spatial eigenfunction analysis and multivariate linear regression (Diniz-Filho et al. 2013 and Legendre et al. 2015)  
i - PCoA to pairwise multivariate genetic distance matrix (Bray-Curtis)
ii - keep PCoA axes based on the broken-stick criterion (Legendre & Legendre 2012)   
iii - response data = kept axes, for redundancy analysis - mutivariate linear regression (RDA)
iv - predictors are spatial eigenfunctions (distance-based Moran's eigenvector maps, dbMEMs)
v - forward selection to reduce number of dbMEMs (Blanchet et al. 2008)
vi - calcuate r^2 assess signficantion using 1000 permutations   
<https://github.com/rforge/sedar/tree/master/pkg> 
both PCNM and packfor    
<http://dr-k-lo.blogspot.com/2012/04/how-to-do-mantel-test-in-r.html>     

<http://popgen.nescent.org/2015-05-18-Dist-SNP.html#section-2.-individual-genetic-distance-euclidean-distance-dist-adegenet> 
ph1 #without TC    
phall #with TC     
```{r}  
#by populaiton, not by individual... oh, because that's how you get distance, right?
ph.genepop <- genind2genpop(ph1)
#tab(ph.genepop)
phall.genepop <- genind2genpop(phall) #genind has 431 indiviudals, down to the 15 populaitons
#tab(phall.genepop)

ph.genepop #no TC, 14 populations
phall.genepop #with TC, 15 populaitons

### TC in = phall.genpop
#goegraphic distance matrix
Dgeo <- distm(include.ind[,c("lon","lat")])
is.euclid(dist(include.ind[,c("lon","lat")]))
Dgeo <- as.dist(Dgeo)

#1 = Nei's distance (not Euclidean)
#Dgen <- dist.genpop(phall.genepop,method=1) #first time did 2 which is Angular or Edwards'; 1=Nei's
Dgen <- dist(phall@tab, method="euclidean")

hist(Dgen)

#.randtest = in C; .rtest = in R
ibd <- mantel.randtest(Dgen,Dgeo) 
#repeat this for a distance matrix of climate variables! climate envelope
ibd
plot(ibd)
```


```{r}
plot(Dgeo,Dgen)
abline(lm(Dgen~Dgeo), col="red")

distgenEUCL <- dist(phall, method = "euclidean", diag = FALSE, upper = FALSE, p = 2)
hist(distgenEUCL)

# loci with at least one sample missing
phall.loci <- genind2loci(phall)
distgenDIFF <- dist.gene(phall.loci, method="pairwise", pairwise.deletion=FALSE, variance=FALSE)
hist(distgenDIFF)

#Percent missing data per population
missing_data <- info_table(phall, type="missing")
sum(missing_data["Total",-13]>0) #10
barplot(missing_data["Total",-13], xlab="Locus", ylab="Percent Missing")
```
Keep loci even if one missing value
```{r}
distgenDIFF <- dist.gene(phall.loci, method="pairwise", pairwise.deletion = TRUE, variance = FALSE)
hist(distgenDIFF)


```

Number of allelic differences between two individuals diss.dist from poppr    
```{r}
distgenDiSS <- diss.dist(phall, percent=FALSE, mat=FALSE)
hist(distgenDiSS)

```
Compare how different genetic distances deal with missing data and which might want to use in Mantel.test   
```{r}
boxplot(distgenEUCL,distgenDIFF,distgenDiSS,dist.genpop(phall.genepop,method=2)) #the last is among populations, not individuals
```

Maybe not the euclidian one, Nei's is not. So the second one? 
```{r}
ibd.ind <- mantel.randtest(Dgeo, distgenDIFF)
ibd.ind
plot(ibd.ind)

```
Classical IBD means clines of genetic differentiation to cause a correlation, or distant and differentiated populations can also result in this pattern
```{r}
plot(Dgeo, distgenDIFF)
abline(lm(distgenDIFF~Dgeo), col="red", lty=2)

```
Visualize density 
```{r}
library(MASS)
dens <- kde2d(Dgeo,distgenDIFF, n=300)
myPal <- colorRampPalette(c("white","blue","gold", "orange", "red"))
plot(Dgeo, distgenDIFF, pch=20,cex=.5)
image(dens, col=transp(myPal(300),.7), add=TRUE)
abline(lm(distgenDIFF~Dgeo))
title("Isolation by distance plot")

```

Monmonier's algorithm - genetic boundaries    
find the path through the strongest genetic distances between heighbours   


Once I have an environmental distance matrix: mantel.partial() - pearson, partial correlation conditioned on the thrid matrix    
```{r}
temp <- phall@pop
temp <- as.numeric(temp)

temp.sp <- temp #Did the order change???
#AN,AS,BR,CG,D,  P,R,RN,   V, WA, WS  <- PhFo 1:5,9:11,13:15
#FC,HN,HS <- PhSc   6:8
#TC <- PhGi 12
temp.sp[temp.sp %in% c(1:5,9:11,13:15)] <- 1
temp.sp[temp.sp %in% c(6:8)] <- 2
temp.sp[temp.sp==12] <- 3

#missed the changing to FC and TC... ?? 
temp.sp2 <- temp
temp.sp2[temp.sp2 %in% c(1:3)] <- 2 #Larimer
temp.sp2[temp.sp2 %in% c(4:14)] <- 1 #Jackson
temp.sp2[temp.sp2 == 15] <- 3 #Grand
  
plot(phall$other$xy, pch=temp, cex=1.5) #looks wrong somehow... points don't match with stated populations
#include.ind which is merged phfo.gen and gen.ind must be in different order than phall
pop(phall)
include.ind$Code

plot(phall$other$xy, pch=)

D <- dist(phall$tab)
gab <- chooseCN(phall$other$xy,ask=FALSE,type=5)


# by species, something in Jackson is listed as phsc
plot(phall$other$xy, pch=temp.sp, cex=1.5)
D.sp <- dist(phall$tab) #here want to group by species? no? 
```

Example shows between two populations, maybe need to go with species, not populations?
```{r}


mon1 <- monmonier(phall$other$xy,D,gab)
```

```{r}
jacksonsoils <- shapefile("Q:/Research/All_Projects_by_Species/aa_Shapefiles_Maps/aa_GENERAL_non-species_files/All_General_Background_Layers/Colorado/soil_co630/JacksonCnt_PhFo/wss_aoi_2018-01-30_12-01-12/spatial/soilmu_a_aoi.shp")

plot(jacksonsoils)

jacksonsoilscoll <- read.delim("Q:/Research/All_Projects_by_Species/aa_Shapefiles_Maps/Phacelia formosula/SoilsCollectionsJackson.txt", header=TRUE, sep=",")

table(jacksonsoilscoll$MUSYM)
table(jacksonsoilscoll$MUKEY)
```


soils <https://www.nrcs.usda.gov/wps/portal/nrcs/detail/soils/survey/?cid=nrcs142p2_053627>
Data from USDA <http://websoilsurvey.nrcs.usda.gov/app/WebSoilSurvey.aspx>   
 1. Analsis Tools -> Overlay -> Spatial Join 2. In spatial join dialog box: -Target features = Points -Join features = Polygons -Join Operation = Join one to one -Right click on 'yield' field in join feature field map, select properties, choose 'Maximum' as merge rule -Match option = Intersect 
Try to get netCDF data for these points
```{r}
soils <- read.delim("Q:/Research/All_Projects_by_Species/Phacelia SPECIES/Phacelia_formosula/Phacelia formosula_abiotic/Walden_Phacelia/SoilsPerPoints.txt",
                    sep = ",")

head(soils)
soils$Population <- gsub('[[:digit:]]+', '', soils$Comment)
soils$Population[soils$Comment == " "] <- "TroublesomeCreek"
unique(soils$Population)

soils$Population[grep("WSE", soils$Population)] <- "WeatherStation"
soils$Population[grep("Brownlee", soils$Population)] <- "Brownlee"
soils$Population[grep("RNA", soils$Population)] <- "ResearchNaturalArea"
soils$Population[grep("iamond", soils$Population)] <- "DiamondJNE"

table(soils$Population)

```


Diniz-Filho et al 2013   
```{r}
library(raster)
library(prism)

options(prism.path = "Q:/Research/All_Projects_by_Species/Astragalus SPECIES/Astragalus_microcymbus/PRISM_asmiclimate")

#Precipitation total, rain and snow
get_prism_monthlys(type="ppt", mon = 1:12, keepZip = FALSE, years = 1980:1993)

#Maximum temperature (average)
get_prism_monthlys(type="tmax", mon = 1:12, keepZip = FALSE, years = 1980:1993)

#Minimum temperature (average)
get_prism_monthlys(type="tmin", mon = 1:12, keepZip = FALSE, years = 1980:1993)

ph.ll <- spTransform(SpatialPoints(cbind(soils$EastingAll,soils$NorthingAll),
                                   proj4string = CRS("+proj=utm +zone=13 + datum=NAD83")),
                     CRS("+proj=longlat +datum=WGS84"))
```

```{r}

ph.cols <- data.frame(coordinates(ph.ll),soils$Population,soils$Ind_Num)


maxs <- grep("tmax", ls_prism_data(absPath=TRUE)[,2])
mins <- grep("tmin", ls_prism_data(absPath = TRUE)[,2])
ppt <- grep("ppt", ls_prism_data(absPath = TRUE)[,2])

avgTemps.max <- lapply(maxs, function(x){
  rastertemps <- raster(ls_prism_data(absPath=TRUE)[x,2])
  data.frame(data = extract(rastertemps, ph.cols[,c("coords.x1","coords.x2")]), 
             date = ls_prism_data()[x,])
})

avgTemps.min <- lapply(mins, function(x){
  rastertemps <- raster(ls_prism_data(absPath=TRUE)[x,2])
  data.frame(data = extract(rastertemps, ph.cols[,c("coords.x1","coords.x2")]), 
             date = ls_prism_data()[x,])
})

avgPrecip <- lapply(ppt, function(x){
  rastertemps <- raster(ls_prism_data(absPath=TRUE)[x,2])
  data.frame(data = extract(rastertemps, ph.cols[,c("coords.x1","coords.x2")]), 
             date = ls_prism_data()[x,])
})

mins.avg <- do.call(rbind, avgTemps.min)
maxs.avg <- do.call(rbind, avgTemps.max)
ppt.avg <- do.call(rbind, avgPrecip)


```

<https://cran.r-project.org/web/packages/dismo/vignettes/sdm.pdf>   
The code above returns a raster with the 18 bioclimate variables covering the whole world with a resoltion of 2.5 minutes of degrees:
averaged over 1960-1990

BIO1 = Annual Mean Temperature
BIO2 = Mean Diurnal Range (Mean of monthly (max temp â min temp))
BIO3 = Isothermality (BIO2/BIO7) (* 100)
BIO4 = Temperature Seasonality (standard deviation *100)
BIO5 = Max Temperature of Warmest Month
BIO6 = Min Temperature of Coldest Month
BIO7 = Temperature Annual Range (BIO5-BIO6)
BIO8 = Mean Temperature of Wettest Quarter
BIO9 = Mean Temperature of Driest Quarter
BIO10 = Mean Temperature of Warmest Quarter
BIO11 = Mean Temperature of Coldest Quarter
BIO12 = Annual Precipitation
BIO13 = Precipitation of Wettest Month
BIO14 = Precipitation of Driest Month
BIO15 = Precipitation Seasonality (Coefficient of Variation)
BIO16 = Precipitation of Wettest Quarter
BIO17 = Precipitation of Driest Quarter
BIO18 = Precipitation of Warmest Quarter
BIO19 = Precipitation of Coldest Quarter
```{r}
install.packages(c('raster', 'rgdal', 'dismo', 'rJava'))

#download big bioclim data elsewhere, change wd
setwd("Q:/Research/All_Projects_by_Species/aa_Shapefiles_Maps/aa_GENERAL_non-species_files/All_General_Background_Layers/World BioClim Date")

setwd("P:/hackathon/Phacelia")

#check out example file
file <- paste(system.file(package="dismo"), "/ex/bradypus.csv", sep="")
bradypus <- read.table(file, header=TRUE, sep=",")
head(bradypus)

phal <- gbif("phacelia", "alba*", geo=FALSE)
phde <- gbif("phacelia", "denticulata*", geo=FALSE)
phha <- gbif("phacelia", "hastata*", geo=FALSE)
phhe <- gbif("phacelia", "heterophylla*", geo=FALSE)
phse <- gbif("phacelia", "sericea*", geo=FALSE)

phgeo <- subset(phse, !is.na(phse$lon) & !is.na(phse$lat))


install.packages("maptools")
library(maptools)

data(wrld_simpl)
plot(wrld_simpl, xlim=c(-150,-100), ylim=c(20,70), axes=TRUE,
     col="light yellow")
points(phgeo$lon, phgeo$lat, col="orange", pch=20, cex=0.75)


bioclim <- getData("worldclim", var = 'bio', res = 2.5)

    
usa <- getData("GADM", country="USA", level=2)
colorado <- usa[usa$NAME_1 == "Colorado",]
counties <- c("Larimer","Jackson","Grand")
ph.counties <- colorado[colorado$NAME_2 %in% grep(paste(counties, collapse="|"),
                                                  colorado$NAME_2, value=TRUE),]
ph.counties <- ph.counties[ph.counties$NAME_2 != "Rio Grande",]
plot(usa)
plot(bioclim$bio1, main="Annual Mean Temperature")
plot(bioclim$bio2, main="Annual Mean Temperature")

#SRTM 90 Elevation
srtm <- getData('SRTM', lon= -106, lat = 41)
#mosaic enough tiles to gt them together!
srtm1 <- getData('SRTM', lon= -106, lat = 40)
strmmosaic <- mosaic(srtm, srtm1, fun=mean)

plot(strmmosaic)
plot(ph.counties, add=TRUE)

ph.p <-data.frame(coordinates(ph.points))


```


Bioclim data for Jackson, Larimer, and Grand counties
```{r}
bioclim.jackson <- getData("worldclim", var='bio', res = 0.5, lon = -106, lat = 41)
bioclim.grand <- getData("worldclim", var='bio', res = 0.5, lon = -106, lat = 40)
bioclim.larimer <- getData("worldclim", var='bio', res = 0.5, lon = -105, lat = 41)


bioclim.ph <- mosaic(bioclim.larimer,bioclim.grand,bioclim.jackson, fun=mean)

plot(bioclim.ph$layer.1)
points(ph.p)

ggplot()+
  geom_path(data=ph.counties, aes(x=long, y=lat, group=group))+
  coord_map()+
  geom_point(data=ph.p, aes(x=coords.x1, y=coords.x2))

#extract rasters to data, should lapply but not sure how
bio1.ph <- extract(bioclim.ph$layer.1, ph.p)
bio2.ph <- extract(bioclim.ph$layer.2, ph.p)
bio3.ph <- extract(bioclim.ph$layer.3, ph.p)
bio4.ph <- extract(bioclim.ph$layer.4, ph.p)
bio5.ph <- extract(bioclim.ph$layer.5, ph.p)
bio6.ph <- extract(bioclim.ph$layer.6, ph.p)
bio7.ph <- extract(bioclim.ph$layer.7, ph.p)
bio8.ph <- extract(bioclim.ph$layer.8, ph.p)
bio9.ph <- extract(bioclim.ph$layer.9, ph.p)
bio10.ph <- extract(bioclim.ph$layer.10, ph.p)
bio11.ph <- extract(bioclim.ph$layer.11, ph.p)
bio12.ph <- extract(bioclim.ph$layer.12, ph.p)
bio13.ph <- extract(bioclim.ph$layer.13, ph.p)
bio14.ph <- extract(bioclim.ph$layer.14, ph.p)
bio15.ph <- extract(bioclim.ph$layer.15, ph.p)
bio16.ph <- extract(bioclim.ph$layer.16, ph.p)
bio17.ph <- extract(bioclim.ph$layer.17, ph.p)
bio18.ph <- extract(bioclim.ph$layer.18, ph.p)
bio19.ph <- extract(bioclim.ph$layer.19, ph.p)

layers <- sapply(1:19, function(x){
  paste("bio",x,".ph",sep="")
})

biodata <- data.frame(soils.unique,bio1.ph,bio19.ph,bio18.ph,
                      bio17.ph,bio16.ph,bio15.ph,bio14.ph,bio13.ph,bio12.ph,
                      bio11.ph,bio10.ph,bio9.ph,
                      bio8.ph,bio7.ph,bio6.ph,
                      bio5.ph,bio4.ph,bio3.ph,bio2.ph)
head(biodata)

# canberra meant for non-negative counts, out, but it does measure relative distance
# binary only for binary data, out
# Euclidean isn't great in high dimensions - squares the differences
# Manhattan just takes absolute value

#Should keep only not correltated ones
cor.table <- cor(biodata[,30:48])
data <- as.data.frame(as.table(cor.table))
combns <- combn(colnames(cor.table),2,FUN=function(x) paste(x,collapse = "_"))
cor.data <- data[data$Var1 != data$Var2, ]
data <- cor.data[paste(cor.data$Var1, cor.data$Var2, sep="_") %in% combns,]
head(data)

data[data$Var1 == "bio1.ph" & data$Freq > 0.7,]
data[data$Var2 == "bio1.ph"& data$Freq > 0.7,]
data[data$Freq > 0.7,]

# Keep only annual precipitation
data <- data[data$Var1 != "bio19.ph" & data$Var2 != "bio19.ph",]
data <- data[data$Var1 != "bio18.ph" & data$Var2 != "bio18.ph",]
data <- data[data$Var1 != "bio17.ph" & data$Var2 != "bio17.ph",]
data <- data[data$Var1 != "bio16.ph" & data$Var2 != "bio16.ph",]
data <- data[data$Var1 != "bio15.ph" & data$Var2 != "bio15.ph",]
data <- data[data$Var1 != "bio14.ph" & data$Var2 != "bio14.ph",]
data <- data[data$Var1 != "bio13.ph" & data$Var2 != "bio13.ph",]

# If keep bio12: get rid of bio3 (Isothermality), keep annual mean temp (1)
data <- data[data$Var1 != "bio3.ph" & data$Var2 != "bio3.ph",]
data <- data[data$Var1 != "bio10.ph" & data$Var2 != "bio10.ph",]
data <- data[data$Var1 != "bio8.ph" & data$Var2 != "bio8.ph",]

# Keep bio2: mean diurnal range, get rid of 4,5,and 7
data <- data[data$Var1 != "bio4.ph" & data$Var2 != "bio4.ph",]
data <- data[data$Var1 != "bio5.ph" & data$Var2 != "bio5.ph",]
data <- data[data$Var1 != "bio7.ph" & data$Var2 != "bio7.ph",]

#Either keep min temp of coldest month (6) or quarter (11)
data <- data[data$Var1 != "bio11.ph" & data$Var2 != "bio11.ph",]

names(biodata[,c(30,38,41,44,48)])
pairs(biodata[,c(30,38,41,44,48)])

bio.dist <- dist(biodata[,c(30,38,41,44,48)], method="manhattan") 

bio.prcomp <- prcomp(biodata[,c(30,38,41,44,48)], center = TRUE)
print(bio.prcomp)
summary(bio.prcomp)

plot.bio <- data.frame(biodata,bio.prcomp$x)

populations <- unique(plot.bio$Population)
plot.bio$Species <- "phsc"
plot.bio$Species[plot.bio$Population %in% paste(populations[c(1:3,5:7,11:15)],sep="|")] <- "phfo"
plot.bio$Species[plot.bio$Population == populations[4]] <- "phgi"


ggplot(plot.bio, aes(PC1,PC2, colour=Population))+
  geom_point()+
  theme_bw()


ggplot(plot.bio, aes(PC1,PC2, colour=Species))+
  geom_point()+
  theme_bw()

## try with princomp
bionames <- names(biodata[,c(30,38,41,44,48)])

pairs(biodata[,c(30,38,41,44,48)])
keep <- c(30,38,41,44,48)
      
ph.pca <- princomp(biodata[,keep], cor=TRUE)
summary(ph.pca)
asmi.load <- loadings(ph.pca) #1: Annual Mean Temperature, 11: Mean temp of coldest quarter, 9: Mean temp of driest quarter


plot.pca <- data.frame(ph.pca$scores, plot.bio)

ggplot(plot.pca, aes(Comp.1,Comp.2,colour = Species))+
  geom_point()+
  theme_bw()

ggplot(plot.bio, aes(bio6.ph, bio2.ph, colour = Species))+
  geom_point()+
  labs(x = "Min Temperature of Coldest Month", 
       y = "Mean Diurnal Range (Mean of monthly (max temp - min temp))")+
#  geom_polygon(aes(fill = Species), alpha = 0.3)+
  theme_bw()


ggplot(plot.bio, aes(bio1.ph, bio9.ph, colour = Species))+
  geom_point()+
  labs(x = "Annual mean temperature", y = "Mean temperature of driest quarter")+
  theme_bw()

ggplot(plot.bio, aes(bio1.ph, bio12.ph, colour = Species))+
  geom_point()+
  labs(x = "Annual mean temperature", y = "Annual Precipitation")+
  theme_bw()


# summer and winter moisture... 
ggplot(plot.bio, aes(bio18.ph, bio19.ph, colour = Species))+
  geom_point()+
  theme_bw()


ggplot(plot.bio, aes(bio11.ph, bio9.ph, colour = Species))+
  geom_point()+
  labs(x = "Mean temperature of coldest quarter", y = "Mean temperature of driest quarter")+
  theme_bw()

ggplot(plot.bio, aes(bio11.ph, bio9.ph, colour = Species))+
  geom_point()+
  labs(x = "Mean temperature of coldest quarter", y = "Mean temperature of driest quarter")+
  theme_bw()

ggplot(plot.bio, aes(bio14.ph, bio19.ph, colour = Species))+
  geom_point()+
  labs(x = "Precipitation of Driest Month", y = "Precipitation of Coldest Quarter")+
  theme_bw()

ggplot(plot.bio, aes(bio6.ph, bio19.ph, colour = Species))+
  geom_point()+
  labs(x = "Min Temperature of Coldest Month", y = "Precipitation of Coldest Quarter")+
  theme_bw()

unique(plot.bio$MUSYM)
unique(plot.bio$MUKIND)
unique(plot.bio$MUKEY)

ggplot(plot.bio, aes(MUSYM, bio12.ph, colour = Species))+
  geom_violin()+
  geom_point()+
  labs(x= "Soil Type", y = "Annual Precipitation")+
  theme_bw()


#Which are correlated? 
data[abs(data$Freq)>0.75,]

# Use daisy to combine bioclim and soil

```


### TO DO:
<http://creativemorphometrics.co.vu/blog/2014/03/27/extracting-climate-data-in-r/>    
get data   
```{r}
setwd("~/tmean") #this is the folder with all the GeoTiffs
library(raster)
library(sp)
library(rgdal)
meanJan <- raster("tmean1_16.tif") #mean temp for January etc.
meanFeb <- raster("tmean2_16.tif")
meanMar <- raster("tmean3_16.tif")
meanApr <- raster("tmean4_16.tif")
meanMaj <- raster("tmean5_16.tif")
meanJun <- raster("tmean6_16.tif")
meanJul <- raster("tmean7_16.tif")
meanAvg <- raster("tmean8_16.tif")
meanSep <- raster("tmean9_16.tif")
meanOkt <- raster("tmean10_16.tif")
meanNov <- raster("tmean11_16.tif")
meanDec <- raster("tmean12_16.tif")
plot(meanJan) #will simply get the basic R plot of a GeoTiff raster




```


<http://www.sthda.com/english/wiki/ade4-and-factoextra-principal-component-analysis-r-software-and-data-mining>

Data cleaning
```{r}
sum(duplicated(soils[,c("EastingAll","NorthingAll")]))
#28

soils.unique <- soils[!duplicated(soils[,c("EastingAll","NorthingAll")]),]
ph.points <- spTransform(SpatialPoints(cbind(soils.unique$EastingAll,soils.unique$NorthingAll),
                                       proj4string = CRS("+proj=utm +zone=13 +datum=NAD83")),
                         CRS("+proj=longlat +datum=WGS84"))

#cross check coordinates
#Make a SpatialPointsDataFrame
library(sp)

ph.p <-data.frame(coordinates(ph.points))

ggplot()+
  geom_path(data=ph.counties, aes(x=long, y=lat, group=group))+
  coord_map()+
  geom_point(data=ph.p, aes(x=coords.x1, y=coords.x2))


```

Sampling bias    
with many samples, subsampling to reduce sampling bias   
ph.points == acg in example
```{r}
r <- raster(ph.points)
#cells are set to 1 degree
res(r) <- 1
# extend the extent of the RasterLayer a little
r <- extend(r, extent(r)+1)
#sample
phsel <- gridSample(ph.points, r, n=1) # must be 1 per degree cell

p <- rasterToPolygons(r)
plot(p, border='gray')
points(ph.points)
```

Background data - for when you don't have absence data   
OR pseudo-absences but these guys don't like as much
dismo to sample random points for background data
```{r}

files <- list.files(path=paste(system.file(package="dismo"), '/ex',
                               sep=''), pattern='grd', full.names=TRUE )

#mask to exclude areas with no data
mask <- raster(files[1])

#select random sample points, set seed
set.seed(1963)
bg <- randomPoints(mask, 500)

plot(!is.na(mask), legend=FALSE)
points(bg, cex=0.5)

#extent to restrict areas from which random points will be drawn
e <- extent(-80, -53, -39, -22)
bg2 <- randomPoints(mask, 50, ext=e)
plot(!is.na(mask), legend=FALSE)
plot(e, add=TRUE, col='red')
points(bg2, cex=0.5)


#Phacelia
rm(mask,bg2,rr)
mask <- raster(xmn=-107, xmx=-105,ymn=40, ymx = 41, nrow=100, ncol=100)
mask[]=runif(100*100)

plot(mask)
plot(ph.counties, add=TRUE)
points(ph.points)

rr <- mask(mask,ph.counties)

plot(rr)
plot(ph.counties, add=TRUE)

bg2 <- randomPoints(rr, 500)
plot(!is.na(mask), legend=FALSE)
plot(rr, add=TRUE, col='red')
points(bg2, cex=0.5)

#circles with a radius of 5 km
x <- circles(rasterToPoints(rr), d=5000, lonlat=TRUE)
pol <- polygons(x)

head(x@presence)
head(x@absence)

# then use rgeos package to dissolve circles (remove boundaries where overlap)
#sample from circles
samp1 <- spsample(pol, 250, type="random", iter=25)
cells <- cellFromXY(mask, samp1)
cells <- unique(cells)

xy <- xyFromCell(mask, cells)

plot(pol, axes=TRUE)
points(xy, cex=0.75, pch=20, col='blue')
```

Raster data - predictor variables    
ASCII files are slow
```{r}
#get elevation from worldclim
w <- getData('alt', country='USA')

files <- list.files(path=paste("Q:/Research/All_Projects_by_Species/aa_Shapefiles_Maps/aa_GENERAL_non-species_files/All_General_Background_Layers/World BioClim Date/bio_2-5m_bil", 
                               sep = ''),
                    pattern='grd', full.names=TRUE)

files2 <- list.files(path=paste("Q:/Research/All_Projects_by_Species/aa_Shapefiles_Maps/aa_GENERAL_non-species_files/All_General_Background_Layers/World BioClim Date",
                                sep = ''),
                     pattern='grd', full.names=TRUE)

usa.alt <- raster("Q:/Research/All_Projects_by_Species/aa_Shapefiles_Maps/aa_GENERAL_non-species_files/All_General_Background_Layers/World BioClim Date/USA1_msk_alt.grd")

m <- data.frame(long = c(max(ph.points@coords[,1]),min(ph.points@coords[,1])),
                lat = c(max(ph.points@coords[,2]),min(ph.points@coords[,2])))
cbind(m, alt = extract(w, m))

# Don't know what the .grd.vat.cpg files are
predictors <- stack(files[c(1,4:21)])

#missing projection
proj4string(predictors) <- CRS("+proj=longlat +datum=WGS84")
proj4string(usa.alt) <- CRS("+proj=longlat +datum=WGS84")

names(predictors)
plot(predictors)
plot(usa.alt)

predictors <- crop(predictors, extent(r)+1)
predictor.alt <- crop(files2)

plot(predictors)

plot(predictors,1)
plot(ph.counties, add=TRUE)
points(ph.points, col="blue", pch =20, cex = 0.5)

```

Create new predictor variables - example: use land cover data and focal() and create new variable that indicates how much forest area is available within Xkm of a grid cell..
```{r}
?focal

```

#Extract values from rasters
```{r}
presvals <- extract(predictors, ph.points)
altvals <- extract(usa.alt, ph.points)

cnts <- extract(ph.counties, ph.points)

#set random seed to always create same random set of points
set.seed(0)

backgr <- randomPoints(predictors, 500)

absvals <- extract(predictors, backgr)

# row for each point 
pb <- c(rep(1, nrow(presvals)), rep(0, nrow(absvals)))
cnts <- c(cnts$NAME_2, rep(0, nrow(absvals)))
site <- c(soils.unique$Population, rep(0, nrow(absvals)))
sdmdata <- data.frame(cnts, site, pb, rbind(presvals, absvals))

#categorical variables   
#SKIP
sdmdata[,'biome'] <- as.factor(sdmdata[,'biome'])

head(sdmdata)
table(sdmdata$cnts)

pairs(sdmdata[,4:22], cex=0.1, fig=TRUE)

#sdmdata[,3:22] <- sapply(sdmdata[,3:22], function(num) as.numeric(num))
```

#Model fitting   
pb - presence vs background points for the three phacelia species
```{r}
m1 <- glm(pb ~ bio1 + bio13 + bio2 + bio3 + bio4 + bio9, data=sdmdata)
class(m1)

summary(m1)

bc <- bioclim(presvals[,c('bio1','bio13','bio2','bio3','bio4','bio9')])
class(bc)
pairs(bc)
```

#Model evaluation
```{r}
#training data set
samp <- sample(nrow(sdmdata), round(0.75 * nrow(sdmdata)))
traindata <- sdmdata[samp,]

traindata <- traindata[traindata[,'pb'] == 1, -(1:3)]

testdata <- sdmdata[-samp,]
bc <- bioclim(traindata)

e <- evaluate(testdata[testdata$pb==1,], testdata[testdata$pb==0,], bc)
plot(e, 'ROC')

#Really want a k-fold data partitioning instead of single random sample
#### START HERE on page 39 of the sdm vignette

```



```{r}
#too many, take out highly correlated ones
cutoff <- 0.75
cor.table <- cor(sdmdata[,-(1:3)])
data <- as.data.frame(as.table(cor.table))
combins <- combn(colnames(cor.table),2,FUN=function(x) paste(x,collapse="_"))
cor.data <- data[data$Var1 != data$Var2, ]
data <- cor.data[paste(cor.data$Var1, cor.data$Var2, sep="_") %in% combins,]
exclude1 <- paste(data$Var2[abs(data$Freq)>cutoff],sep=",")
exclude2 <- paste(data$Var1[abs(data$Freq)>cutoff],sep=",")


#Which are correlated? 
data.cor <- data[abs(data$Freq)>cutoff,]
correlated <- c(grep(paste(c(exclude1,exclude2), collapse="|"),names(sdmdata), value=TRUE))

pairs(sdmdata[,correlated], cex=0.1, fig=TRUE)

forstep <- sdmdata[,c(grep(paste(exclude1, collapse="|"),
                            names(sdmdata), value=TRUE, invert=TRUE))]

pairs(forstep[,-(1:3)])

pairs(sdmdata[,c(unique(exclude2),unique(exclude1))])
```

Step regression - which factors explain differences in species   
convergence issues: logistf <http://cran.r-project.org/web/packages/logistf/logistf.pdf>
```{r}
glm(cnts~bio1+bio13+bio13+bio2+bio3+bio4+bio9,
    data=forstep[cnts!="0",], family = binomial, control = list(maxit=50))

step1 <- step(glm(cnts~bio1+bio13+bio13+bio2+bio3+bio4+bio9,
                 data=forstep, family=binomial),control = list(maxit=70))

#Don't need the background points for these
ggplot(sdmdata[cnts!="0",], aes(x=cnts, y=bio2))+
  geom_boxplot()

# 3 same for Larimer and Grand
ggplot(sdmdata[cnts!="0",], aes(bio1,bio4,colour=cnts))+ 
  geom_point()

#15 splits Jackson
ggplot(sdmdata[cnts!="0",], aes(bio1,bio3,colour=cnts))+ 
  geom_point()

ggplot(sdmdata[cnts!="0",], aes(bio1,bio2,colour=cnts))+ 
  geom_point()

ggplot(sdmdata[cnts!="0",], aes(bio1,bio13,colour=cnts))+ 
  geom_point()

ggplot(sdmdata[cnts!="0",], aes(bio1,bio9,colour=cnts))+ 
  geom_point()


```

Environmental factors and background points
```{r}
ggplot(sdmdata, aes(x=cnts, y=bio15))+
  geom_boxplot()

ggplot(sdmdata, aes(x=cnts, y=bio1))+
  geom_boxplot()

ggplot(sdmdata, aes(x=cnts, y=bio2))+
  geom_boxplot()

ggplot(sdmdata, aes(x=cnts, y=bio13))+
  geom_boxplot()

ggplot(sdmdata, aes(x=cnts, y=bio9))+
  geom_boxplot()



```



#Ignore Grand
```{r}
sdmdata.phfo.phsc <- sdmdata[cnts=="Jackson"|cnts=="Larimer",]
sdmdata.phfo.phsc$cnts <- factor(sdmdata.phfo.phsc$cnts)

step1 <- step(glm(cnts~bio10+bio13+bio15+bio18+bio2+bio8,
                 data=sdmdata.phfo.phsc, family=binomial),control = list(maxit=70))

ggplot(sdmdata.phfo.phsc, aes(bio2, bio18, colour=cnts))+
  geom_point()+
  stat_ellipse()

ggplot(sdmdata.phfo.phsc, aes(bio6, bio14, colour=cnts))+
  geom_point()

```




<https://www.rforge.net/doc/packages/climates/html/bioclim.html>
```{r}
install.packages("climates") #nope, how?!


```


Now have environmental variables (by going through the sdm vignette)
follow vegan tutorial, trying to get environmental variables   
<http://cc.oulu.fi/~jarioksa/opetus/metodi/vegantutor.pdf>
```{r}


```


ecodist   
simple mantel statistic  - degree of dissimilarity in one datset compared to detree of dissimilarity in another independently-derived dataset   
<https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3873175/>   
<http://www.molecularecologist.com/2015/06/ibeibd-contour-plots-in-r/>  

Forester et al. 2016 Molecular Ecology 
##### START HERE #####
1) PCA 
2) RDA reduncancy analysis : contrained ordination extends linear regression to multivariate response data to maximize proportion of response variable that is explained. (response variables: genetic data; linear comintation of predictor variables (environemtnal data)) 
```{r}
library(labdsv)
vegdist()

ph.df <- genind2df(ph1)
head(ph.df)
ph.df <- as.data.frame(ph.df)
ph.df[,2:13] <- sapply(ph.df[,2:13], function(x) as.numeric(x))

ph.vegdist <- vegdist(ph.df[,-1], method = "bray", na.rm = TRUE)
disana(ph.vegdist)

ph.pco <- pco(ph.vegdist)
ph.pco$eig

barplot(ph.pco$eig)

ph.genepop <- genind2genpop(ph1)
tab(ph.genepop)
```

<http://adegenet.r-forge.r-project.org/files/tutorial-basics.pdf>  
Some of this would work better for the environmental variables
```{r}
ph.tab <- tab(ph.genepop, NA.method="mean")
ph.pca <- dudi.pca(ph.tab, scannf=TRUE, scale=FALSE) # nf = 4  #can determine number dimensions in the final results

summary(ph.pca)
phxy <- ph.pca$co
   
s.corcircle(phxy, label = row.names(phxy), grid = TRUE,
            box = FALSE)

temp <- as.integer(pop(ph1))
myCol <- transp(c("red","blue"),.7)[temp]
myPch <- c(15:17)[temp]

plot(ph.pca$li)
plot(ph.pca$li, col = myCol, pch=myPch) 

## use wordcloud for non-overlapping labels
textplot(ph.pca$li[,1], ph.pca$li[,2], words=rownames(ph.tab), cex=1.4, new=FALSE)

## legend the axes by adding loadings
#abline(h=0,v=0,col="grey",lty=2)
#s.arrow(ph.pca$c1*.5, add.plot=TRUE)
legend("topright", pch=c(15,17), col=transp(c("blue","red"),.7),
leg=c("Group A","Group B"), pt.cex=2)

#https://trapa.cz/sites/default/files/r_mol_data_phylogen.pdf
# Kernel density
s.label(ph.pca$li, clabel = 0.75)
s.kde2d(ph.pca$li, cpoint=0, add.plot = TRUE)

```

Pluess et al 20016 New Phytologist
```{r}
#Variable factor map
pca.space <- princomp(pca.ph[,-(1:3)], cor=TRUE)
summary(pca.space)
ph.load <- loadings(pca.space)
ph.pc <- predict(pca.space)

ph.pc <- data.frame(ph.pc, pca.ph)

summary(lm(Comp.1~alt, data=ph.pc))

rm(ph.pc)
#PCA of factors
pca.ph <- sdmdata[cnts!="0",]
pca.ph$alt <- altvals

cutoff <- 0.75
cor.table <- cor(pca.ph[,-(1:3)])
data <- as.data.frame(as.table(cor.table))
combins <- combn(colnames(cor.table),2,FUN=function(x) paste(x,collapse="_"))
cor.data <- data[data$Var1 != data$Var2, ]
data <- cor.data[paste(cor.data$Var1, cor.data$Var2, sep="_") %in% combins,]
exclude1 <- paste(data$Var2[abs(data$Freq)>cutoff],sep=",")
exclude2 <- paste(data$Var1[abs(data$Freq)>cutoff],sep=",")


#Which are correlated? 
data.cor <- data[abs(data$Freq)>cutoff,]
correlated <- c(grep(paste(c(exclude1,exclude2), collapse="|"),names(pca.ph), value=TRUE))

pairs(pca.ph[,correlated[1:5]], cex=0.1, fig=TRUE)
pairs(pca.ph[,correlated[6:10]], cex=0.1, fig=TRUE)

forpca <- pca.ph[,c(grep(paste(exclude1, collapse="|"),
                         names(pca.ph), value=TRUE, invert=TRUE))]



ph.pca <- princomp(forpca[,-(1:3)], cor=TRUE)
summary(ph.pca)
ph.load <- loadings(ph.pca)
ph.pc <- predict(ph.pca)

ph.pc <- data.frame(ph.pc, pca.ph)

summary(lm(Comp.1~alt, data=ph.pc))
```


```{r}
ggplot(ph.pc, aes(Comp.1, Comp.2, colour = cnts))+
  geom_point()+
  stat_ellipse()

```


redundancy analysis (RDA): combines PCA on allele frequencies and multiple regression
Meirmans Molecular Ecology "Seven common mistakes in pouplaiton genetics and how to avoid them"


<https://www.analyticsvidhya.com/blog/2016/04/complete-tutorial-tree-based-modeling-scratch-in-python/> 
```{r}


```
