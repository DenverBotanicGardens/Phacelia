---
title: "IBD"
author: "Michelle DePrenger-Levin"
date: "November 17, 2016"
output: html_document
---

Climate envelope

Nov17PhFo_data_all2loci... in case I need the genetic data again

```{r}
rm(list=ls())
```

<http://rfunctions.blogspot.com/2016/10/simple-and-partial-mantel-tests.html>    
<http://dr-k-lo.blogspot.com/2012/04/how-to-do-mantel-test-in-r.html>     
<http://adegenet.r-forge.r-project.org/files/tutorial-basics.pdf>     

```{r, warning=FALSE, message=FALSE}
library(raster)
library(rgdal)
library(maptools)
library(devtools)
library(vegan)
library(MASS)

# devtools::install_github("ropensci/prism")
library(prism)
library(dismo)
library(ggplot2)
#library(Imap)
#library(wordcloud)
library(MASS)
library(adegenet)
#library(pegas)
library(ape)
library(ade4)
library(ggmap)
library(boot)
#library(ecodist)
library(geosphere)
#library(poppr)
# library(car)
#library(strataG)
library(rgeos)
#library(diveRsity)
library(hierfstat)
library(sp)
ph.dist <- read.csv("Q:/Research/Lab/Projects/Phacelia formosula/Project Information/Phacelia project information with GPS centroids 2016_pdm.csv")

# Genepop input file with PhGi (TC) 431 individuals
phall <- read.genepop("C:/Users/deprengm/Dropbox/Denver Botanic Gardens Postdoctoral Genetic Files/Phacelia project/Manuscript/GenAlExAnalyses_Nov2017/Genpop_PhfoData_Nov2017.gen") # Nov2017... PhfoData.. 6Dec2017 does not have troublesome creek.

```

Pairwise distance matrix
```{r}

# Get rid of TC
ph.dist1 <- ph.dist[ph.dist$Code != "T",]

#Convert the Northing/Easting to lat/long
ph.dist.UTM <- SpatialPoints(ph.dist[,c("Easting","Northing")],
                        proj4string = CRS("+proj=utm +zone=13 +datum=NAD83"))
ph.dist.LatLon <- spTransform(ph.dist.UTM, CRS("+proj=longlat +datum=WGS84"))
ph.dist <- data.frame(ph.dist,ph.dist.LatLon)
plot(ph.dist.LatLon) # 3 counties

ph.dist1.UTM <- SpatialPoints(ph.dist1[,c("Easting","Northing")],
                        proj4string = CRS("+proj=utm +zone=13 +datum=NAD83"))
ph.dist1.LatLon <- spTransform(ph.dist1.UTM, CRS("+proj=longlat +datum=WGS84"))
ph.dist1 <- data.frame(ph.dist1,ph.dist1.LatLon)
plot(ph.dist1.LatLon) # 2 counties

#These are just populations, not individuals
identical(ph.dist[-15,],ph.dist1) # TRUE
spatialdist1.noTC <- dist(ph.dist1[,3:4]) # Northing, Easting is in UTM, Easting.1 == Lon; Northing.1 == Lat

spatialdist.noTC <- dist(ph.dist[-15,3:4]) #exclude Troublesome Creek
spatialdist.TC <- dist(ph.dist[,3:4])

spatialdist1.noTC;spatialdist.noTC
identical(spatialdist1.noTC,spatialdist.noTC) # They look the same but are somehow different

# from DAPC and <http://adegenet.r-forge.r-project.org/files/tutorial-basics.pdf>


#Dgeo <- spatialdist.noTC

# ggmap is all broken
# ggmap(get_map(c(-107,40,-105.25,41)))+
#   geom_point(data=ph.dist, aes(Easting.1,Northing.1))

```

spatial Analysis of principal components (sPCA) complements classical PCA retrieving non-trivial spatial genetic patterns   
Spatial and genetic data per individual -> don't want by individual Jan 26, 2018  
  - Thibaut in his vignette for adegenet says you can do isolation by 
```{r}
 

table(phall@pop)
#Change to match T -> TC; F -> FC; B -> BR
currentlevels <- levels(phall@pop)
currentlevels[currentlevels=="T"] <- "TC"
currentlevels[currentlevels=="F"] <- "FC"
currentlevels[currentlevels=="B"] <- "BR"
currentlevels[currentlevels=="D"] <- "DJ"
currentlevels[currentlevels=="P"] <- "PW"
currentlevels[currentlevels=="R"] <- "RW"
currentlevels[currentlevels=="V"] <- "VR"
levels(phall@pop) <- currentlevels

# GENIND with no Troublesome Creek !!
ph1 <- phall[phall@pop != "TC"] #395 individuals
table(ph1@pop)


# Can store spatial information in @other$xy  
# Location information for each individual under Northing/Easting (need lat/lon) for individuals as $Code AN... and $Ind. 1:30 
phfo.gen <- read.csv("Q:/Research/Lab/Projects/Phacelia formosula/Project Information/Phacelia project information with GPS data 2016_all.csv")

nrow(phfo.gen) #451 - some individuals were thrown out for the genetic data.
codelevels <- levels(phfo.gen$Code)
codelevels[codelevels=="D"] <- "DJ"
codelevels[codelevels=="P"] <- "PW"
codelevels[codelevels=="R"] <- "RW"
codelevels[codelevels=="V"] <- "VR"
levels(phfo.gen$Code) <- codelevels
table(phfo.gen$Code)
phfo.gen$Code <- factor(phfo.gen$Code, levels=levels(phall@pop))


phfo.indloc <- read.csv("C:/Users/deprengm/Dropbox/Denver Botanic Gardens Postdoctoral Genetic Files/Phacelia project/Manuscript/GenAlExAnalyses_Nov2017/LatLon_PhfoData_Nov2017.csv")

table(phfo.indloc$SimpleCode)
curlev <- levels(phfo.indloc$SimpleCode)
curlev[curlev=="T"] <- "TC"
curlev[curlev=="F"] <- "FC"
curlev[curlev=="B"] <- "BR"
curlev[curlev=="D"] <- "DJ"
curlev[curlev=="P"] <- "PW"
curlev[curlev=="R"] <- "RW"
curlev[curlev=="V"] <- "VR"
levels(phfo.indloc$SimpleCode) <- curlev

phfo.gen1 <- phfo.gen[!grepl("TC",phfo.gen$Code),]
phfo.indloc1 <- phfo.indloc[!grepl("TC",phfo.indloc$SimpleCode),]
#Still match these locaitons with the individuals from phall
table(phall@pop)
table(phfo.gen$Code) # Has Troublesome Creek
table(ph1@pop)
table(phfo.indloc$SimpleCode) # Has Troublesome Creek
table(phfo.gen1$Code) # Zero TC
table(phfo.indloc1$SimpleCode) # Zero TC


```

```{r}
# help make levels match?
# phfo.indloc$SimpleCode <- factor(phfo.indloc$SimpleCode, levels= levels(phall@pop))
# table(phfo.indloc$SimpleCode)

#Morphology  
phfo.loc <- read.csv("C:/Users/deprengm/Dropbox/Denver Botanic Gardens Postdoctoral Genetic Files/Phacelia project/Phacelia 2014 collection and morphology data/geoloc_ph.csv")
table(phfo.loc$Population.Code) #only collections from FC, RN, BR, AS, and TC

phfo.loc$Population.Code <- factor(phfo.loc$Population.Code, levels=levels(phall@pop))
table(phall@pop)
table(phfo.indloc$SimpleCode)

#phall are individuals from phfo.indloc
# So take the SimpleCode and IndNum from phfo.indloc and the Northing and Easting from phfo.gen matching Code and Ind.
# phfo.gen$Code <- as.character(phfo.gen$Code)
# phfo.indloc$SimpleCode <- as.character(phfo.indloc$SimpleCode)


#Want to keep order of phall which might come from phfo.indloc
phfo.indloc$ID <- 1:nrow(phfo.indloc)
phfo.UTM <- merge(phfo.gen,phfo.indloc[,c(1,3:5)],
                  by.x=c("Code","Ind."),by.y=c("SimpleCode","IndNum"))

#Same without TC
phfo.indloc1$ID <- 1:nrow(phfo.indloc1)
phfo.UTM1 <- merge(phfo.gen1,phfo.indloc1[,c(1,3:5)],
                  by.x=c("Code","Ind."),by.y=c("SimpleCode","IndNum"))


#Back to phfo.indloc order
phfo.UTM <- phfo.UTM[with(phfo.UTM, order(phfo.UTM$ID)),]
phfo.UTM$Code <- factor(phfo.UTM$Code, levels=levels(phall@pop))
table(phfo.UTM$Code)
sum(table(phfo.UTM$Code)) #425


phfo.UTM1 <- phfo.UTM1[with(phfo.UTM1, order(phfo.UTM1$ID)),]
phfo.UTM1$Code <- factor(phfo.UTM1$Code, levels=levels(ph1@pop))
table(phfo.UTM1$Code)
sum(table(phfo.UTM1$Code)) #395

table(phfo.UTM$Code)

#Convert phfo.UTM$Easting and $Northing to lat/lon
# phfo.UTM.SP <- SpatialPoints(phfo.UTM[,c("Easting","Northing")],
#                         proj4string = CRS("+proj=utm +zone=13 +datum=NAD83"))
phfo.UTM.SP <- SpatialPointsDataFrame(phfo.UTM[,c("Easting","Northing")], phfo.UTM,
                        proj4string = CRS("+proj=utm +zone=13 +datum=NAD83"))
phfo.LatLon <- spTransform(phfo.UTM.SP, CRS("+proj=longlat +datum=WGS84"))
phfo.UTM <- data.frame(phfo.UTM,phfo.LatLon)
names(phfo.UTM)[which(names(phfo.UTM) %in% c("Easting.1","Northing.1"))] <- c("lon","lat")

# Version without TC
phfo.UTM.SP1 <- SpatialPointsDataFrame(phfo.UTM1[,c("Easting","Northing")],phfo.UTM1,
                        proj4string = CRS("+proj=utm +zone=13 +datum=NAD83"))
phfo.LatLon1 <- spTransform(phfo.UTM.SP1, CRS("+proj=longlat +datum=WGS84"))
phfo.UTM1 <- data.frame(phfo.UTM1,phfo.LatLon1)
names(phfo.UTM1)[which(names(phfo.UTM1) %in% c("Easting.1","Northing.1"))] <- c("lon","lat")

#Want XY coordinates from phfo.gen that are individuals found in gen.ind
phall@other$xy <- phfo.UTM[,c("lon","lat")]
identical(phfo.UTM[-grep("TC",phfo.UTM$Code),c("lon","lat")],phfo.UTM1[,c("lon","lat")])
phfo.UTM[-grep("TC",phfo.UTM$Code),c("lon","lat")];phfo.UTM1[,c("lon","lat")] # not idendical but look the same?!?!
# ph1@other$xy <- phfo.UTM[-grep("TC",phfo.UTM$Code),c("lon","lat")]
ph1@other$xy <- phfo.UTM1[,c("lon","lat")]
nrow(phall@other$xy) #425
nrow(ph1@other$xy) # 395
```


###################################################################################

# IBD and IBE

With TC
Get distance matrix for genetic distance by population (15)
```{r}
Dgen <- dist.genpop(genind2genpop(phall), method=1) #1: Nei's 2: Angular Edward's Euclidean distance
Dgenind <- dist(phall@tab) #euclidean
Dgenind.maximum <- dist(phall@tab, method="max")
# Dgeo <- dist(phall$other$xy)
Dgeo <- dist(phfo.UTM[,c("Easting","Northing")])
#These are the genetic and geographic distance for 425 individuals
ibd <- mantel.randtest(Dgenind,Dgeo) #OH dear, Dgen is 15 populations, Dgeo are all individuals
ibd

plot(ibd)

ibdmax <- mantel.randtest(Dgeo,Dgenind.maximum)
ibdmax

vegan::mantel(Dgeo,Dgenind)

#vegan version
vegan::mantel(Dgeo,Dgenind, permutations = 9999)

#Distance with UTM is now in meters, distance of lat/lon are who knows
plot(density(Dgeo), main = "Distance of geo, red = log transformed") # xlim=c(-11,11), 


#similar "rank"?

determinant(as.matrix(Dgenind), logarithm = TRUE)
eigens <- eigen(as.matrix(Dgenind)) #the variance
plot(density(eigens$values), main="variance")
points(max(eigens$values),0.1) #2757.032 that's some crazy variance
```

Takes very long time, that's why output saved
strataG
```{r, eval=FALSE}
gtypes_phfo <- genind2gtypes(phall)

#
Hstats(gtypes_phfo)

output_pw_phfo <- pairwiseTest(gtypes_phfo)

output_pw_phfo$pair.mat$`G''st`

#Fst(phall, pop=phall@pop)
save(output_pw_phfo, file="P:/hackathon/Phacelia/output_pw_phfo.rda")

```

```{r}
load("P:/hackathon/Phacelia/output_pw_phfo.rda")

colnums <- c()
for(i in 2:425){
  colnums <- c(colnums,i:425)
}

colslabels <- phall@pop[c(colnums)]
firstones <- rle(as.numeric(colslabels)) #want to label once for each group
labelonce <- apply(do.call(cbind,firstones),1,FUN=function(x){
  label<-x[2]
  NAs<-rep(NA,x[1]-1)
  c(label,NAs)   #if it's by down each column?
})
labels <- do.call(c,labelonce)
str(as.numeric(labels))

labels2 <- labels 
labels2[426:(length(labels2))] <- NA

labels3 <- labels2
labels3 <- levels(phall@pop)[labels3]

plot(jitter(Dgeo),Dgenind, col=colslabels,pch=as.numeric(colslabels), cex=0.75) #the lower triangle by lower triangle
text(Dgeo,jitter(rep(1,length(Dgenind)),factor=15), 
     labels=labels3, cex=0.75, col=labels2)
abline(lm(Dgenind~Dgeo))
#legend("bottomright", legend = unique(phall@pop), col=as.numeric(labels2),pch=16)

summary(lm(Dgenind~Dgeo))

plot(lm(Dgenind~Dgeo))
#KS goodness of fit test, low probability that the genetic and geographic distance matrices are the same distribution. 
ks.test(Dgenind, Dgeo)
ks.test(Dgeo, plnorm)
ks.test(Dgenind, plnorm)
ks.test(Dgenind, punif)

```

```{r}
'%ni%' <- Negate('%in%')

phGrand <- phall[phall@pop == "TC"] #30
phJackson <- phall[!(phall@pop %in% c("FC","HN","HS","TC"))] #330
phLarimer <- phall[(phall@pop %in% c("FC","HN","HS"))] #65

# phJacksonandLarimer <- phall[phall@pop != "TC"]
phJacksonandLarimer <- ph1


Dgenind_Grand <- dist(phGrand@tab)
Dgenind_Jackson <- dist(phJackson@tab)
Dgenind_Larimer <- dist(phLarimer@tab)

Dgeo_Grand <- dist(phfo.UTM[grepl("TC",phfo.UTM$Code),c("Easting","Northing")])
Dgeo_Jackson <- dist(phfo.UTM[phfo.UTM$Code %ni% c("FC","HN","HS","TC"),c("Easting","Northing")])
Dgeo_Larimer <- dist(phfo.UTM[phfo.UTM$Code %in% c("FC","HN","HS"),c("Easting","Northing")])

Dgeo_JacksonandLarimer <- dist(phfo.UTM1[,c("Easting","Northing")])

# Lat/Lon
# Dgeo_Grand <- dist(phGrand$other$xy)
# Dgeo_Jackson <- dist(phJackson$other$xy)
# Dgeo_Larimer <- dist(phLarimer$other$xy)

Dgenind_JacksonandLarimer <- dist(phJacksonandLarimer@tab)

#hierfstat:: 
Grand.hf <- genind2hierfstat(phGrand)
#Grand.dist.hf <- varcomp.glob(Grand.hf$pop, Grand.hf[,-1]) #nope, only one population
Jackson.hf <- genind2hierfstat(phJackson)
# Jackson.dist.hf <- varcomp.glob(Jackson.hf,Jackson.hf[,-1] ) # ???


matFst <- pairwise.fst(phall)
matFst1 <- pairwise.fst(ph1)

plot(phall$other$xy$lon,phall$other$xy$lat)
points(phGrand$other$xy$lon,phGrand$other$xy$lat, col="red", cex=2)
points(phJackson$other$xy$lon,phJackson$other$xy$lat, col="blue", cex=1.5)
points(phLarimer$other$xy$lon,phLarimer$other$xy$lat, col="green", cex=2)
points(phJacksonandLarimer$other$xy$lon,phJacksonandLarimer$other$xy$lat, col="purple", cex=5)


plot(ph1$other$xy$lon,ph1$other$xy$lat)
# points(phGrand$other$xy$lon,phGrand$other$xy$lat, col="red", cex=2)
points(phJackson$other$xy$lon,phJackson$other$xy$lat, col="blue", cex=1.5)
points(phLarimer$other$xy$lon,phLarimer$other$xy$lat, col="green", cex=2)
points(phJacksonandLarimer$other$xy$lon,phJacksonandLarimer$other$xy$lat, col="purple", cex=5)

colocounties <- readOGR(dsn="Q:/Research/All_Projects_by_Species/aa_Shapefiles_Maps/aa_GENERAL_non-species_files/All_General_Background_Layers/Colorado/CO_Counties", layer="counties_wgs84")
plot(colocounties)

plot(colocounties, xlim=c(-106.6,-105.05),ylim=c(40.25,41))
pointLabel(coordinates(colocounties),labels=colocounties$COUNTY, cex=0.5)


```

# With Grand County, Troublesome Creek, skip to next for no TC
```{r}
layout(matrix(c(2,3,5,
                4,1,6),2,3,byrow=TRUE))

#plot 1
par(mar=c(2,4.5,4.5,0.5))
dens <-kde2d(Dgeo,Dgenind, n=100)
myPal <- colorRampPalette(c("white","blue","gold", "orange", "red"))
plot(Dgeo, Dgenind, pch=20,cex=.5, xlim=c(0,1),ylim=c(0,10), ylab="", xlab="meters")
image(dens, col=transp(myPal(300),.7), add=TRUE)
abline(lm(Dgenind~Dgeo))
title("Isolation by distance plot")

#plot 2
par(mar=c(1,4.5,4.5,0.5))
dens <-kde2d(Dgeo_Jackson,Dgenind_Jackson, n=100)
myPal <- colorRampPalette(c("white","blue","gold", "orange", "red"))
plot(Dgeo_Jackson, Dgenind_Jackson, pch=20,cex=.5, xlab="",ylab="Euclidean distance")
image(dens, col=transp(myPal(300),.7), add=TRUE)
abline(lm(Dgenind_Jackson~Dgeo_Jackson))
title("Jackson County")

#plot 3
par(mar=c(1,4.5,4.5,0.5))
dens <-kde2d(Dgeo_Larimer,Dgenind_Larimer, n=100)
myPal <- colorRampPalette(c("white","blue","gold", "orange", "red"))
plot(Dgeo_Larimer, Dgenind_Larimer, pch=20,cex=.5, xlab="",ylab="")
image(dens, col=transp(myPal(300),.7), add=TRUE)
abline(lm(Dgenind_Larimer~Dgeo_Larimer))
title("Larimer County")

#plot 4
par(mar=c(2,4.5,4.5,0.5))
dens <-kde2d(Dgeo_Grand,Dgenind_Grand, n=100)
myPal <- colorRampPalette(c("white","blue","gold", "orange", "red"))
plot(Dgeo_Grand, Dgenind_Grand, pch=20,cex=.5, xlab="meters",ylab="Euclidean distance" )
image(dens, col=transp(myPal(300),.7), add=TRUE)
abline(lm(Dgenind_Grand~Dgeo_Grand))
title("Grand County")

#plot 5
par(mar=c(2,4.5,4.5,0.5))
dens <-kde2d(Dgeo_JacksonandLarimer,Dgenind_JacksonandLarimer, n=300)
myPal <- colorRampPalette(c("white","blue","gold", "orange", "red"))
plot(Dgeo_JacksonandLarimer, Dgenind_JacksonandLarimer, pch=20,cex=.5, xlab="meters",ylab="Euclidean distance" )
image(dens, col=transp(myPal(300),.7), add=TRUE)
abline(lm(Dgenind_JacksonandLarimer~Dgeo_JacksonandLarimer))
title("Jackson and Larimer County")

#plot 6
plot(phall$other$xy$lon,phall$other$xy$lat)
points(phGrand$other$xy$lon,phGrand$other$xy$lat, col="red", cex=2)
points(phJackson$other$xy$lon,phJackson$other$xy$lat, col="blue", cex=1.5)
points(phLarimer$other$xy$lon,phLarimer$other$xy$lat, col="green", cex=2)
points(phJacksonandLarimer$other$xy$lon,phJacksonandLarimer$other$xy$lat, col="purple", cex=5)
```


Save figure of genetic by geographic distance plots
```{r}
jpeg("C:/Users/deprengm/Dropbox/Denver Botanic Gardens Postdoctoral Genetic Files/Phacelia project/Manuscript/Figures/Isolationxdistxgen.jpg",
     width=200, height=200,units='mm', res=300)

layout(matrix(c(4,4,4,
                4,4,5,
                1,2,3),3,3,byrow=TRUE))

#plot 1
dens1 <-kde2d(Dgeo_JacksonandLarimer,Dgenind_JacksonandLarimer, n=100)
myPal <- colorRampPalette(c("grey100","grey80","grey50", "grey10","black"))
plot(Dgeo_JacksonandLarimer, Dgenind_JacksonandLarimer, pch=20,cex=.5, xlim=c(0,1),ylim=c(0,10), ylab="Genetic Distance (Euclidean)", xlab="")
image(dens1, col=transp(myPal(300),.7), add=TRUE)
abline(lm(Dgenind_JacksonandLarimer~Dgeo_JacksonandLarimer))
title("Jackson and Larimer")

#plot 2
dens <-kde2d(Dgeo_Jackson,Dgenind_Jackson, n=100)
# myPal <- colorRampPalette(c("white","blue","gold", "orange", "red"))
plot(Dgeo_Jackson, Dgenind_Jackson, pch=20,cex=.5, xlab="",ylab="Euclidean distance")
image(dens, col=transp(myPal(300),.7), add=TRUE)
abline(lm(Dgenind_Jackson~Dgeo_Jackson))
title("Jackson County")

#plot 3
dens <-kde2d(Dgeo_Larimer,Dgenind_Larimer, n=100)
# myPal <- colorRampPalette(c("white","blue","gold", "orange", "red"))
plot(Dgeo_Larimer, Dgenind_Larimer, pch=20,cex=.5, xlab="",ylab="")
image(dens, col=transp(myPal(300),.7), add=TRUE)
abline(lm(Dgenind_Larimer~Dgeo_Larimer))
title("Larimer County")

phfo.labelpoints <- phfo.LatLon[!duplicated(phfo.LatLon$Code),]

#plot 4
par(mar=c(0,0,0,0))
plot(colocounties, xlim=c(-106.6,-105.35),ylim=c(40.5,41))
pointLabel(coordinates(colocounties)-0.05,labels=colocounties$COUNTY, cex=0.95)
pointLabel(coordinates(phfo.labelpoints), labels = phfo.labelpoints@data$Code)
points(phfo.labelpoints, pch=16, cex=0.75)


#plot 5

par(mar=c(0,0,0,0))
plot(colocounties, border="grey50")
# pointLabel(coordinates(colocounties)-0.05,labels=colocounties$COUNTY, cex=0.75)
# points(phfo.LatLon, pch=16)
segments(-106.6,40.5,-106.6,41, lwd=2)
segments(-105.35,40.5,-105.35,41, lwd=2)
segments(-106.6,40.5,-105.35,40.5, lwd=2)
segments(-106.6,41,-105.35,41, lwd=2)

dev.off()

```
Figure 1    
```{r}
jpeg("C:/Users/deprengm/Dropbox/Denver Botanic Gardens Postdoctoral Genetic Files/Phacelia project/Manuscript/Figures/Figure1_sitemap.jpg",
     width=200, height=120,units='mm', res=300)

layout(matrix(c(1,1,2,
                1,1,1),2,3,byrow=TRUE))

phfo.labelpoints <- phfo.LatLon[!duplicated(phfo.LatLon$Code),]

#plot 1
par(mar=c(0,0,0,0))
plot(colocounties, xlim=c(-106.6,-105.45),ylim=c(40.5,41))
pointLabel(coordinates(colocounties)-0.05,labels=colocounties$COUNTY, cex=0.95)
pointLabel(coordinates(phfo.labelpoints), labels = phfo.labelpoints@data$Code)
points(phfo.labelpoints, pch=16, cex=0.75)


#plot 2
par(mar=c(0,0,0,0))
plot(colocounties, border="grey50")
# pointLabel(coordinates(colocounties)-0.05,labels=colocounties$COUNTY, cex=0.75)
# points(phfo.LatLon, pch=16)
segments(-106.6,40.5,-106.6,41, lwd=2)
segments(-105.45,40.5,-105.45,41, lwd=2)
segments(-106.6,40.5,-105.45,40.5, lwd=2)
segments(-106.6,41,-105.45,41, lwd=2)

dev.off()


```


. ** Suggestion is a "partial Mantel testing association between the matrix of genetic distances, a model matrix of cluster membership, with matrix of geographical distances as a covariate** However, with a barrier, this test is not conservative, will still claim isolation by distance (when there is none). 

Simluations of IBD
```{r}
simulation <- "phfo_1530indiv"
sim_filenames <- list.files("Q:/Research/Stats & Software/EasyPOP")
phfo_15 <- sim_filenames[grep(simulation, sim_filenames)]
phfo_15 <- phfo_15[grep(".gen", phfo_15)]

genepop_sims <- list()
for(i in 1:(length(phfo_15))){
  #print(paste("Q:/Research/Stats & Software/EasyPOP/",
   #                                       phfo_15[i],
    #                                      sep=""))
  genepop_sims[[i]] <- read.genepop(paste("Q:/Research/Stats & Software/EasyPOP/",
                                          phfo_15[i],
                                          sep=""))
}

# So now can do measurements on this list
genepop_sims[[1]] # 15,000 individuals; 12 loci; 71 alleles; size: 5 Mb
phall #425 individuals; 12 loci; 113 alleles; size: 243.5 Kb

dist_sim <- list()
for(i in 1:(length(genepop_sims))){
  dist_sim[[i]] <- dist(genepop_sims[[i]][floor(runif(425, 1,450))]) #want 425 indiviuals to match
}


ibd_sims <- list()
for(i in 1:(length(dist_sim))){
  ibd_sims[[i]] <- mantel.randtest(Dgeo, dist_sim[[i]])
}

plot(Dgeo, dist_sim[[1]])
points(jitter(Dgeo),dist_sim[[2]], col="red", cex=0.5)
points(jitter(Dgeo),dist_sim[[3]], col="blue", cex=0.5)
points(jitter(Dgeo),dist_sim[[4]], col="green", cex=0.5)

```



#Isolation by distance   
```{r}
## without TC Phacelia gina-glennea
Dgenind.noTC <- dist(ph1@tab) #euclidean
Dgenind.maximum.noTC <- dist(ph1@tab, method="max")
Dgeo.noTC <- dist(ph1$other$xy)
#These are the genetic and geographic distance for 425 individuals
ibd.noTC <- mantel.randtest(Dgenind.noTC,Dgeo.noTC) #OH dear, Dgen is 15 populations, Dgeo are all individuals
ibd.noTC

plot(ibd.noTC)


vegan::mantel(Dgeo.noTC,Dgenind.noTC)

ibdmax <- mantel.randtest(Dgeo,Dgenind.maximum)
ibdmax

#vegan version
vegan::mantel(Dgeo,Dgenind, permutations = 9999)
# 1. Classical IBD would result in continuous clines of genetic differentiation 
# 2. distant and differentiated populations also results in this pattern. So...

#Plot- can see patches
dens.tc <- kde2d(Dgeo.noTC,Dgenind.noTC, n=300)
myPal <- colorRampPalette(c("white","blue","gold", "orange", "red"))
plot(Dgeo.noTC, Dgenind.noTC, pch=20,cex=.5)
image(dens.tc, col=transp(myPal(300),.7), add=TRUE)
abline(lm(Dgenind.noTC~Dgeo.noTC))
title("Isolation by distance plot")

#Convert the Northing/Easting to lat/long
ptsutm <- SpatialPoints(phfo.gen[,c("Easting","Northing")],
                        proj4string = CRS("+proj=utm +zone=13 +datum=NAD83"))
ptsgeo <- spTransform(ptsutm, CRS("+proj=longlat +datum=WGS84"))

latlonphfo <- data.frame(phfo.gen,ptsgeo)
```

#Mantel test    
##2018.01.12_updates  
        - want to make PCA of soils and climate for distance matric of environment, compare to distance matrix of genetic    
ape
ade4

Isolation by distance (IBD) and Isolation by environment (IBE)
1) Mantel test
vegan - Forester et al 2016    
spatial eigenfunction analysis and multivariate linear regression (Diniz-Filho et al. 2013 and Legendre et al. 2015)  
i - PCoA to pairwise multivariate genetic distance matrix (Bray-Curtis)
ii - keep PCoA axes based on the broken-stick criterion (Legendre & Legendre 2012)   
iii - response data = kept axes, for redundancy analysis - mutivariate linear regression (RDA)
iv - predictors are spatial eigenfunctions (distance-based Moran's eigenvector maps, dbMEMs)
v - forward selection to reduce number of dbMEMs (Blanchet et al. 2008)
vi - calcuate r^2 assess signficantion using 1000 permutations   
<https://github.com/rforge/sedar/tree/master/pkg> 
both PCNM and packfor    
<http://dr-k-lo.blogspot.com/2012/04/how-to-do-mantel-test-in-r.html>     

<http://popgen.nescent.org/2015-05-18-Dist-SNP.html#section-2.-individual-genetic-distance-euclidean-distance-dist-adegenet> 










# Climate envelope analysis
soils <https://www.nrcs.usda.gov/wps/portal/nrcs/detail/soils/survey/?cid=nrcs142p2_053627>
Data from USDA <http://websoilsurvey.nrcs.usda.gov/app/WebSoilSurvey.aspx>   
 1. Analsis Tools -> Overlay -> Spatial Join 2. In spatial join dialog box: -Target features = Points -Join features = Polygons -Join Operation = Join one to one -Right click on 'yield' field in join feature field map, select properties, choose 'Maximum' as merge rule -Match option = Intersect 
Try to get netCDF data for these points

Diniz-Filho et al 2013   
```{r, eval=FALSE}
options(prism.path = "Q:/Research/All_Projects_by_Species/Astragalus SPECIES/Astragalus_microcymbus/PRISM_asmiclimate")

#Precipitation total, rain and snow
get_prism_monthlys(type="ppt", mon = 1:12, keepZip = FALSE, years = 1980:1993)

#Maximum temperature (average)
get_prism_monthlys(type="tmax", mon = 1:12, keepZip = FALSE, years = 1980:1993)

#Minimum temperature (average)
get_prism_monthlys(type="tmin", mon = 1:12, keepZip = FALSE, years = 1980:1993)

```

Skip this, already saved, can load in next chunk 
```{r, eval=FALSE}
options(prism.path = "Q:/Research/All_Projects_by_Species/Astragalus SPECIES/Astragalus_microcymbus/PRISM_asmiclimate")

maxs <- grep("tmax", ls_prism_data(absPath=TRUE)[,2])
mins <- grep("tmin", ls_prism_data(absPath = TRUE)[,2])
ppt <- grep("ppt", ls_prism_data(absPath = TRUE)[,2])

avgTemps.max <- lapply(maxs, function(x){
  rastertemps <- raster(ls_prism_data(absPath=TRUE)[x,2])
  data.frame(data = extract(rastertemps, phfo.UTM[,c("lon","lat")]),              
             date = ls_prism_data()[x,])
})

avgTemps.min <- lapply(mins, function(x){
  rastertemps <- raster(ls_prism_data(absPath=TRUE)[x,2])
    data.frame(data = extract(rastertemps, phfo.UTM[,c("lon","lat")]), 
             date = ls_prism_data()[x,])
})

avgPrecip <- lapply(ppt, function(x){
  rastertemps <- raster(ls_prism_data(absPath=TRUE)[x,2])  
  data.frame(data = extract(rastertemps, phfo.UTM[,c("lon","lat")]), 
             date = ls_prism_data()[x,])
})
# These are the points, not the averages yet
mins.avg <- do.call(rbind, avgTemps.min)
maxs.avg <- do.call(rbind, avgTemps.max)
ppt.avg <- do.call(rbind, avgPrecip)

# also want the variance. so the SE of the averages

save(mins.avg, file="P:/hackathon/Phacelia/mins_avg.rda")
save(maxs.avg, file="P:/hackathon/Phacelia/maxs_avg.rda")
save(ppt.avg, file="P:/hackathon/Phacelia/ppt_avg.rda")


```


```{r}
load("P:/hackathon/Phacelia/mins_avg.rda")
load("P:/hackathon/Phacelia/maxs_avg.rda")
load("P:/hackathon/Phacelia/ppt_avg.rda")

```

<https://cran.r-project.org/web/packages/dismo/vignettes/sdm.pdf>   
The code above returns a raster with the 18 bioclimate variables covering the whole world with a resoltion of 2.5 minutes of degrees:
averaged over 1960-1990

    BIO1 = Annual Mean Temperature  
    BIO2 = Mean Diurnal Range (Mean of monthly (max temp - min temp))  
    BIO3 = Isothermality (BIO2/BIO7) (* 100)  
    BIO4 = Temperature Seasonality (standard deviation *100)  
    BIO5 = Max Temperature of Warmest Month  
    BIO6 = Min Temperature of Coldest Month  
    BIO7 = Temperature Annual Range (BIO5-BIO6)   
    BIO8 = Mean Temperature of Wettest Quarter  
    BIO9 = Mean Temperature of Driest Quarter  
    BIO10 = Mean Temperature of Warmest Quarter  
    BIO11 = Mean Temperature of Coldest Quarter  
    BIO12 = Annual Precipitation  
    BIO13 = Precipitation of Wettest Month  
    BIO14 = Precipitation of Driest Month  
    BIO15 = Precipitation Seasonality (Coefficient of Variation)  
    BIO16 = Precipitation of Wettest Quarter  
    BIO17 = Precipitation of Driest Quarter  
    BIO18 = Precipitation of Warmest Quarter  
    BIO19 = Precipitation of Coldest Quarter  

Bioclim data for Jackson, Larimer, and Grand counties  
 Need to run lines 160-223
```{r}
bioclim.phfo <- getData("worldclim", var='bio', res = 0.5, lon = -106, lat = 41)

usa <- getData("GADM", country="USA", level=2)
colorado <- usa[usa$NAME_1 == "Colorado",]
counties <- c("Larimer","Jackson","Grand")
ph.counties <- colorado[colorado$NAME_2 %in% grep(paste(counties, collapse="|"),
                                                 colorado$NAME_2, value=TRUE),]
ph.counties <- ph.counties[ph.counties$NAME_2 != "Rio Grande",]

plot(bioclim.phfo[[1]]) 
# plot(bioclim.phfo[[1]], xlim=c(-106.5,-105),ylim=c(40,41.125))
points(phfo.UTM[,c("lon","lat")], col=phfo.UTM$Code)
plot(ph.counties, add=TRUE)

```

#Background points
To create background points:  
```{r, eval=FALSE}
# Save the circles and the convex hull as shapefile, break into 100^2 km chunkcs, feed into the soils usda site and get that coverage for phfo
xSPDF <- circles(phfo.UTM1[,c("Easting","Northing")], d=5000, lonlat=FALSE) # could do a larger background if don't use the soil layers
pntSPDF <- spsample(polygons(xSPDF), n=300, "stratified")
proj4string(xSPDF@polygons)  <- CRS("+proj=utm +zone=13 ellps=NAD83 +ellps=WGS84")
XSPDF_latlon <- spTransform(xSPDF@polygons, CRS("+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0"))
proj4string(pntSPDF)<- CRS("+proj=utm +zone=13 ellps=NAD83 +ellps=WGS84")
pntSPDF_latlon <- spTransform(pntSPDF, CRS("+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0"))


plot(bioclim.phfo[[1]], xlim=c(-107.5,-104),ylim=c(39,42.125)) +
plot(XSPDF_latlon, add=TRUE) +
points(phfo.UTM[,c("lon","lat")], col=phfo.UTM$Code, pch=3, cex=1.25) +
plot(ph.counties, add=TRUE) +
points(pntSPDF_latlon, pch=16, col="blue", cex=0.5) 


```


Create a raster of approximately 100,000 acres for the soils usda website to download portions to cover the entire area of the three county speices. 


#Soils   
 
Steps to get soil layers <"Q:\Research\All_Projects_by_Species\Phacelia SPECIES\Phacelia_formosula\Phacelia formosula_abiotic\Modelling\Soil_layer_data_extraction\Notes_on_soil_data_file_making.docx">   
```{r, echo=FALSE}
filenames <- list.files("Q:/Research/All_Projects_by_Species/aa_Shapefiles_Maps/Phacelia formosula/SoilLayers")
flnms <- unique(sapply(strsplit(filenames,"[.]"),'[',1)) #13 layers I have

# AWS025
# depthWT
# ph030
# stext

shape <- list()
#Get all the soil layers I made, Jessie made most of them!
# for(i in flnms){
shape <- lapply(flnms, function(i){
    readOGR("Q:/Research/All_Projects_by_Species/aa_Shapefiles_Maps/Phacelia formosula/SoilLayers", layer = paste(i))
})

#Dissolve polygons by type
types <- c("AWS","depthWT","ph030","stext")

typeall <- lapply(types, function(tp){
  do.call(rbind,lapply(which(flnms %in% flnms[grep(tp,flnms)]),
                       function(x){
                         shape[[x]]
                         }))
  })

plot(typeall[[1]]) +
points(phfo.LatLon1, pch=16, col="blue")

save(typeall, file="C:/Users/deprengm/Dropbox/Denver Botanic Gardens Postdoctoral Genetic Files/Phacelia project/SoilLayers.Rda")

typeall[[4]]

```


<https://cran.r-project.org/web/packages/dismo/vignettes/sdm.pdf>  
Overlap methods for background and presence points  Ward et al. 2009; Phillips and Elith, 2011  
# see pntSPDF within xSPDF


Now extract points from all the bioclim layers, plot them in a pretty layout
```{r}

load("C:/Users/deprengm/Dropbox/Denver Botanic Gardens Postdoctoral Genetic Files/Phacelia project/SoilLayers.Rda")

#extract background and county points
# add background points to other list
proj4string(pntSPDF) <- CRS("+init=epsg:26913")
pntSPDF.latlon <- spTransform(pntSPDF, CRS(proj4string(phfo.LatLon1)))

lonlat <- pntSPDF.latlon@coords
utms <- pntSPDF@coords
names(utms) <- c("Easting","Northing")
names(lonlat) <- c("lon", "lat")
backgroundpoints <- data.frame(Code= "All",1:nrow(lonlat),utms,"background",lonlat)
names(backgroundpoints) <- c("Code","Ind.","Easting","Northing","NAME","lon","lat")
phfo.prbg <- rbind(phfo.UTM1[,c("Code","Ind.","Easting","Northing","NAME","lon","lat")],
                   backgroundpoints)

#take over County to group by county for plotting, 1:Jackson,2:Larimer,3:Grand
phfo.prbg$County <- "background"
phfo.prbg$County[phfo.prbg$Code %in% c("HN","HS","FC")] <- "Larimer"
phfo.prbg$County[phfo.prbg$Code %ni% c("HN","HS","FC","All")] <- "Jackson"

#bio is a list of bioclim values at each point

#extract rasters to data
# bio<-list()
# for(i in 1:19){
bio <- lapply(1:19,function(i){
  extract(bioclim.phfo[[i]], phfo.prbg[,c("lon","lat")]) 
})

plot(bioclim.phfo[[1]])

#one matrix with bioclims and soils for presence points
abiotic.phfo <- do.call(cbind,bio) #matrix of (425::TC; 395::withoutTC) presence points and 300 background points by 19 bioclim variables

abiotic.phfo <- data.frame(abiotic.phfo)
names(abiotic.phfo) <- paste("Bio",1:19,sep="")
nrow(phfo.prbg)

soils <- lapply(1:4, function(i){
  extract(typeall[[i]], phfo.prbg[,c("lon","lat")])
})

abiotic.phfo <- data.frame(abiotic.phfo,SurfTExt = soils[[4]]$SurfText,
                           pHwater = soils[[3]]$pHwater,
                           Dep2WatTbl = soils[[2]]$Dep2WatTbl,
                           AvaliableSW = soils[[1]]$AWS025,
                           phfo.prbg)

save(abiotic.phfo, file="C:/Users/deprengm/Dropbox/Denver Botanic Gardens Postdoctoral Genetic Files/Phacelia project/abiotic.phfo.Rda")

```


```{r}
#load("P:/hackathon/Phacelia/abiotic_phfo.rda")
load("P:/hackathon/Phacelia/typeall_soils.rda")
load("C:/Users/deprengm/Dropbox/Denver Botanic Gardens Postdoctoral Genetic Files/Phacelia project/abiotic.phfo.Rda")

# canberra meant for non-negative counts, out, but it does measure relative distance
# binary only for binary data, out
# Euclidean isn't great in high dimensions - squares the differences
# Manhattan just takes absolute value


```






```{r}
library(corrplot)

names(abiotic.phfo)

cor_matrix <- cor(abiotic.phfo[,-c(20,24:length(abiotic.phfo))])
corrplot(cor_matrix, method="square", type="upper")

corvalues <- as.data.frame(as.table(cor_matrix))
corvalues[abs(corvalues$Freq)>0.75,]

# Get rid of 10, 11, 3,4,6,7,8,11,12,14,15,17,19

```

Bio11:19 are all highly correlated (>0.5) so for simplicity, just keep Bio12, annual precipitation  
Bio2:9, which to keep? 6 Min Temperature of Coldest Month?   
1,6,10,12

BIO1 = Annual Mean Temperature     
BIO5 = Max Temperature of Warmest Month   
BIO6 = Min Temperature of Coldest Month     
BIO10 = Mean Temperature of Warmest Quarter    
BIO12 = Annual Precipitation    


```{r}

cor(abiotic.phfo[,c("Bio1","Bio2","Bio5","Bio9","Bio13","pHwater","Dep2WatTbl","AvaliableSW")])
checkover75 <- as.data.frame(as.table(cor(abiotic.phfo[,c("Bio1","Bio2","Bio5","Bio9","Bio13","pHwater","Dep2WatTbl","AvaliableSW")])))

checkover75[abs(checkover75$Freq)>0.75,]
# cor(abiotic.phfo[,c("Bio9","Bio10","Bio5","Bio12","pHwater","Dep2WatTbl","AvaliableSW")])

cor_matrix <- cor(abiotic.phfo[,c("Bio9","Bio10","Bio12","pHwater","Dep2WatTbl","AvaliableSW")])
corrplot(cor_matrix, method="square", type="upper")

# forPCA <- phfo.bioclim.soils[,c("bio1","bio7","bio9","bio12")]
forPCA <- abiotic.phfo[,c("Bio1","Bio2","Bio5","Bio9","Bio13","pHwater","Dep2WatTbl","AvaliableSW")]
```

2018-09-07 try getting rid if correlated over 75%



Principal components Analysis
```{r}
phfopca <- princomp(forPCA, cor=TRUE) #use the correlation matrix, not covariance

sumforplot <- summary(phfopca)
sumforplot$center
sumforplot$scale
PoV <- phfopca$sdev^2/sum(phfopca$sdev^2) #The proportion of the variance (standard deviation^2) for each componant to the total variance 
phfo.load <- loadings(phfopca)
phfo.pc <- predict(phfopca)

pcaphfo.abiotic.phfo <- data.frame(phfo.pc,abiotic.phfo)

#Not quite, just want the background points
meanComp1 <- aggregate(Comp.1~County, data=pcaphfo.abiotic.phfo, mean)
meanComp2 <- aggregate(Comp.2~County, data=pcaphfo.abiotic.phfo, mean)

# I'd want to show 2 standard deviations to show the breadth of possible environemtns in which these populations fall
SDComp1 <- aggregate(Comp.1~County, data=pcaphfo.abiotic.phfo, sd)
SDComp2 <- aggregate(Comp.2~County, data=pcaphfo.abiotic.phfo, sd)

#Confidence interval around the mean, not really want I want to show
CIComp1 <- aggregate(Comp.1~County, data=pcaphfo.abiotic.phfo,
                     function(x) qnorm(1-0.05/2)*(sd(x)/sqrt(length(x))))
CIComp2 <- aggregate(Comp.2~County, data=pcaphfo.abiotic.phfo,
                     function(x) qnorm(1-0.05/2)*(sd(x)/sqrt(length(x))))

```

```{r}
jpeg(paste("C:/Users/deprengm/Dropbox/Denver Botanic Gardens Postdoctoral Genetic Files/Phacelia project/Manuscript/Figures/PCA_Bio1_2_5_9_13_pH_WT_ASM.jpg"), width=150, height=150, units="mm", res=300)
# 
# layout(matrix(c(2,4,1,3),2,2, byrow=TRUE), widths=c(3,1), heights=c(1,3), TRUE)
# par(mai=c(1,1,.1,.1)) #margins for plot 1

plot(pcaphfo.abiotic.phfo$Comp.1[pcaphfo.abiotic.phfo$County=="background"],
     pcaphfo.abiotic.phfo$Comp.2[pcaphfo.abiotic.phfo$County=="background"], 
     col=rgb(0,0,0,0.05),pch=16,
     xlab=paste("Comp.1 (Proportion of Variance ",round(PoV[1],2)*100,"%)",
                sep=""), 
     ylab=paste("Comp.2 (Proportion of Variance ", round(PoV[2],2)*100,
                "%)", sep=""))
points(meanComp1[4,2],meanComp2[4,2], pch=16)
arrows(meanComp1[4,2],meanComp2[4,2],
      meanComp1[4,2]+2*SDComp1[4,2],meanComp2[4,2],
      length=0.1,angle=90)
arrows(meanComp1[4,2],meanComp2[4,2],
      meanComp1[4,2]-2*SDComp1[4,2],meanComp2[4,2],
      length=0.1,angle=90)
arrows(meanComp1[4,2],meanComp2[4,2],
      meanComp1[4,2],meanComp2[4,2]+2*SDComp2[4,2],
      length=0.1,angle=90)
arrows(meanComp1[4,2],meanComp2[4,2],
      meanComp1[4,2],meanComp2[4,2]-2*SDComp2[4,2],
      length=0.1,angle=90)
points(pcaphfo.abiotic.phfo$Comp.1[pcaphfo.abiotic.phfo$County=="Jackson"],
     pcaphfo.abiotic.phfo$Comp.2[pcaphfo.abiotic.phfo$County=="Jackson"], 
     pch = 16)
points(pcaphfo.abiotic.phfo$Comp.1[pcaphfo.abiotic.phfo$County=="Larimer"],
     pcaphfo.abiotic.phfo$Comp.2[pcaphfo.abiotic.phfo$County=="Larimer"], 
     pch=2)
# points(pcaphfo.abiotic.phfo$Comp.1[pcaphfo.abiotic.phfo$County==3],
#      pcaphfo.abiotic.phfo$Comp.2[pcaphfo.abiotic.phfo$County==3],
#      pch=3)
legend("topright",
       pch=c(16,2),
       legend = c("Jackson","Larimer")) 

dev.off()
```


```{r}
#plot 2 Comp.1
par(mai=c(.1,1,.1,.1)) 
plot(density(pcaphfo.abiotic.phfo$Comp.1[pcaphfo.abiotic.phfo$County=="background"]),
     xaxt='n',
     main="",
     col=rgb(0,0,0,0.5),
     ylim=c(0,1.2))
lines(density(pcaphfo.abiotic.phfo$Comp.1[pcaphfo.abiotic.phfo$County=="Jackson"]),
      lty=1)
lines(density(pcaphfo.abiotic.phfo$Comp.1[pcaphfo.abiotic.phfo$County=="Larimer"]),
      lty=2)
# lines(density(pcaphfo.abiotic.phfo$Comp.1[pcaphfo.abiotic.phfo$County==3]),
#       lty=3)

yhist4 <- hist(pcaphfo.abiotic.phfo$Comp.2[pcaphfo.abiotic.phfo$County=="background"], plot=FALSE)
yhist1 <- hist(pcaphfo.abiotic.phfo$Comp.2[pcaphfo.abiotic.phfo$County=="Jackson"], plot=FALSE)
yhist2 <- hist(pcaphfo.abiotic.phfo$Comp.2[pcaphfo.abiotic.phfo$County=="Larimer"], plot=FALSE)
# yhist3 <- hist(pcaphfo.abiotic.phfo$Comp.2[pcaphfo.abiotic.phfo$County==3], plot=FALSE)


#trail plot 3


#plot 3 Comp.2
par(mai=c(1,.1,.1,.1)) 
plot(yhist4$density, seq(from=min(yhist4$breaks),
                         to=max(yhist4$breaks),
                         length.out = length(yhist4$density)),
     yaxt='n',
     main="",
     type="l",
     col=rgb(0,0,0,0.15),
     xlim=c(0,1.2), xlab="Density")
lines(yhist1$density, seq(from=min(yhist1$breaks),
                         to=max(yhist1$breaks)+0.1,
                         length.out = length(yhist1$density)),
     lty=1, main="",xaxt='n')
lines(yhist2$density, seq(from=min(yhist2$breaks),
                         to=max(yhist2$breaks)+0.1,
                         length.out = length(yhist2$density)),
      lty=2)
# lines(yhist3$density, seq(from=min(yhist3$breaks),
#                          to=max(yhist3$breaks),
#                          length.out = length(yhist3$density)),
#       lty=3)

#Line legend
par(mai=c(.1,.1,.1,.1))
plot(1:6,1:6, type='n', axes=FALSE, main="")
legend("topright", legend =c("Jackson","Larimer",
                             # "Grand",
                             "Background"),
       # lty=c(1:3,1),
       lty=c(1,2,1),
       # col=c(rep("black",3),"grey"),
       col=c(rep("black",2),"grey"),
       bty='n')

# dev.off()

# table(pcaphfo.abiotic.phfo$County)
# Larimer==2; Jackson==1; get rid of Grand==3; background==4
```

```{r}
marginal_plot = function(x, y, group = NULL, data = NULL, lm_show = FALSE, lm_formula = y ~ x, bw = "nrd0", adjust = 1, alpha = 1, plot_legend = T, ...){
  require(scales)
  ###############
  # Plots a scatterplot with marginal probability density functions for x and y. 
  # Data may be grouped or ungrouped. 
  # For each group, a linear fit can be plotted. It is hidden by default, but can be shown by providing lm_show = TRUE.
  # The model can be modified using the 'lm_formula' argument.
  # The 'bw' and 'adjust' argument specify the granularity used for estimating probability density functions. See ?density for more information.
  # For large datasets, opacity may be decreased by setting alpha to a value between 0 and 1.
  # Additional graphical parameters are passed to the main plot, so you can customize axis labels, titles etc.
  ###############
  moreargs = eval(substitute(list(...)))
  
  # prepare consistent df
  if(missing(group)){
    if(missing(data)){
      if(length(x) != length(y)){stop("Length of arguments not equal")}
      data = data.frame(x = as.numeric(x), y = as.numeric(y))
    } else {
      data = data.frame(x = as.numeric(data[,deparse(substitute(x))]), 
                        y = as.numeric(data[,deparse(substitute(y))]))
    }
    if(sum(!complete.cases(data)) > 0){
      warning(sprintf("Removed %i rows with missing data", sum(!complete.cases(data))))
      data = data[complete.cases(data),]
    }
    group_colors = "black"
  } else {
    if(missing(data)){
      if(length(x) != length(y) | length(x) != length(group)){stop("Length of arguments not equal")}
      data = data.frame(x = as.numeric(x), y = as.numeric(y), group = as.factor(group))
    } else {
      data = data.frame(x = as.numeric(data[,deparse(substitute(x))]), 
                        y = as.numeric(data[,deparse(substitute(y))]),
                        group = as.factor(data[,deparse(substitute(group))]))
    }
    if(sum(!complete.cases(data)) > 0){
      warning(sprintf("Removed %i rows with missing data", sum(!complete.cases(data))))
      data = data[complete.cases(data),]
    }
    data = subset(data, group %in% names(which(table(data$group) > 5)))
    data$group = droplevels(data$group)
    group_colors = rainbow(length(unique(data$group)))
  } 
  
  # log-transform data (this is need for correct plotting of density functions)
  if(!is.null(moreargs$log)){
    if(!moreargs$log %in% c("y", "x", "yx", "xy")){
      warning("Ignoring invalid 'log' argument. Use 'y', 'x', 'yx' or 'xy.")
    } else {
      data = data[apply(data[unlist(strsplit(moreargs$log, ""))], 1, function(x) !any(x <= 0)), ]
      data[,unlist(strsplit(moreargs$log, ""))] = log10(data[,unlist(strsplit(moreargs$log, ""))])
    }
    moreargs$log = NULL # remove to prevent double logarithm when plotting
  }
  
  # Catch unwanted user inputs
  if(!is.null(moreargs$col)){moreargs$col = NULL}
  if(!is.null(moreargs$type)){moreargs$type = "p"}
  
  # get some default plotting arguments
  if(is.null(moreargs$xlim)){moreargs$xlim = range(data$x)} 
  if(is.null(moreargs$ylim)){moreargs$ylim = range(data$y)}
  if(is.null(moreargs$xlab)){moreargs$xlab = deparse(substitute(x))}
  if(is.null(moreargs$ylab)){moreargs$ylab = deparse(substitute(y))}
  if(is.null(moreargs$las)){moreargs$las = 1} 
  
  # plotting
  tryCatch(expr = {
    ifelse(!is.null(data$group), data_split <- split(data, data$group), data_split <- list(data))
    orig_par = par(no.readonly = T)
    par(mar = c(0.25,5,1,0))
    layout(matrix(1:4, nrow = 2, byrow = T), widths = c(10,3), heights = c(3,10))
    
    # upper density plot
    plot(NULL, type = "n", xlim = moreargs$xlim, ylab = "density",
         ylim = c(0, max(sapply(data_split, function(group_set) max(density(group_set$x, bw = bw)$y)))), main = NA, axes = F)
    axis(2, las = 1)
    mapply(function(group_set, group_color){lines(density(group_set$x, bw = bw, adjust = adjust), col = group_color, lwd = 2)}, data_split, group_colors)
    
    # legend
    par(mar = c(0.25,0.25,0,0))
    plot.new()
    if(!missing(group) & plot_legend){
      legend("center", levels(data$group), fill = group_colors, border = group_colors, bty = "n", title = deparse(substitute(group)), title.adj = 0.1)
    }
    
    # main plot
    par(mar = c(4,5,0,0))
    if(missing(group)){
      do.call(plot, c(list(x = quote(data$x), y = quote(data$y), col = quote(scales::alpha("black", alpha))), moreargs))
    } else {
      do.call(plot, c(list(x = quote(data$x), y = quote(data$y), col = quote(scales::alpha(group_colors[data$group], alpha))), moreargs))
    }
    axis(3, labels = F, tck = 0.01)
    axis(4, labels = F, tck = 0.01)
    box()
    
    if(lm_show == TRUE & !is.null(lm_formula)){
      mapply(function(group_set, group_color){
        lm_tmp = lm(lm_formula, data = group_set)
        x_coords = seq(min(group_set$x), max(group_set$x), length.out = 100)
        y_coords = predict(lm_tmp, newdata = data.frame(x = x_coords))
        lines(x = x_coords, y = y_coords, col = group_color, lwd = 2.5)
      }, data_split, rgb(t(ceiling(col2rgb(group_colors)*0.8)), maxColorValue = 255))
    }
    
    # right density plot
    par(mar = c(4,0.25,0,1))
    plot(NULL, type = "n", ylim = moreargs$ylim, xlim = c(0, max(sapply(data_split, function(group_set) max(density(group_set$y, bw = bw)$y)))), main = NA, axes = F, xlab = "density")
    mapply(function(group_set, group_color){lines(x = density(group_set$y, bw = bw, adjust = adjust)$y, y = density(group_set$y, bw = bw)$x, col = group_color, lwd = 2)}, data_split, group_colors)
    axis(1)
  }, finally = {
    par(orig_par)
  })
}
```


```{r}
jpeg("C:/Users/deprengm/Dropbox/Denver Botanic Gardens Postdoctoral Genetic Files/Phacelia project/Manuscript/Figures/pHwater_DepthtoWaterTable.jpg",
     width=150, height=125,units='mm', res=300)
     
marginal_plot(x=pHwater, y=Dep2WatTbl,
              data=pcaphfo.abiotic.phfo[pcaphfo.abiotic.phfo$County!="background",],
              group=County,
              xlab="pH",
              ylab="Depth to water table")

dev.off()

# write.table(table(pcaphfo.abiotic.phfo$SurfText, pcaphfo.abiotic.phfo$Code),
#             "clipboard", sep="\t", row.names=TRUE)
```

```{r}
jpeg("C:/Users/deprengm/Dropbox/Denver Botanic Gardens Postdoctoral Genetic Files/Phacelia project/Manuscript/Figures/AvailableSurfaceWater0_25cm__pH.jpg",
     width=150, height=125,units='mm', res=300)

marginal_plot(x=AvaliableSW, y=pHwater,
              data=pcaphfo.abiotic.phfo[pcaphfo.abiotic.phfo$County!="background",],
              group=County,
              xlab="Avaliable surface water",
              ylab="pH")

dev.off()
```

```{r}


marginal_plot(x=Comp.1, y=Comp.2, data=pcaphfo.abiotic.phfo[pcaphfo.abiotic.phfo$County<3,],
              group=County,
              xlab="Comp 1",
              ylab="Comp 2")
```

```{r}
cor_soil <- cor(phfo.bioclim.soils[,c(40:42)], use = "pairwise.complete.obs")
corrplot(cor_soil)

meanDepth <- aggregate(AWS025~County, data=pcaphfo.abiotic.phfo, mean)
meanph <- aggregate(pHwater~County, data=pcaphfo.abiotic.phfo, mean)
SDDepth <- aggregate(AWS025~County, data=pcaphfo.abiotic.phfo, sd)
SDph <- aggregate(pHwater~County, data=pcaphfo.abiotic.phfo, sd)

CIDepth <- aggregate(AWS025~County, data=pcaphfo.abiotic.phfo,
                     function(x) qnorm(1-0.05/2)*(sd(x)/sqrt(length(x))))
CIph <- aggregate(pHwater~County, data=pcaphfo.abiotic.phfo,
                  function(x) qnorm(1-0.05/2)*(sd(x)/sqrt(length(x))))
```

```{r}
plot(pcaphfo.abiotic.phfo$AWS025[pcaphfo.abiotic.phfo$County<4],
     pcaphfo.abiotic.phfo$pHwater[pcaphfo.abiotic.phfo$County<4], type="n",
     xlab="Avaliable surface water", ylab="pH")
points(meanDepth[-4,2],meanph[-4,2], pch=21, cex=2, col=c("red","blue","goldenrod"))
# for(i in 1:3){
#  arrows(meanDepth[i,2],meanph[i,2],
#       meanDepth[i,2]+CIDepth[i,2],meanph[i,2],
#       length=0.1,angle=90)
#  arrows(meanDepth[i,2],meanph[i,2],
#        meanDepth[i,2]-CIDepth[i,2],meanph[i,2],
#        length=0.1,angle=90)
#  arrows(meanDepth[i,2],meanph[i,2],
#        meanDepth[i,2],meanph[i,2]+CIph[i,2],
#        length=0.1,angle=90)
#  arrows(meanDepth[i,2],meanph[i,2],
#        meanDepth[i,2],meanph[i,2]-CIph[i,2],
#        length=0.1,angle=90)
# }
points(pcaphfo.abiotic.phfo$AWS025[pcaphfo.abiotic.phfo$County=="Larimer"],
     pcaphfo.abiotic.phfo$pHwater[pcaphfo.abiotic.phfo$County=="Larimer"], 
     pch = 16, col="red")
points(pcaphfo.abiotic.phfo$AWS025[pcaphfo.abiotic.phfo$County=="Larimer"],
     pcaphfo.abiotic.phfo$pHwater[pcaphfo.abiotic.phfo$County=="Larimer"], col="blue",      pch=17)
points(pcaphfo.abiotic.phfo$AWS025[pcaphfo.abiotic.phfo$County==3],
     pcaphfo.abiotic.phfo$pHwater[pcaphfo.bioclim.soils$County==3],     col="goldenrod", pch=18)
legend("bottomleft",
       pch=c(16,17,18),
       col=c("red","blue","goldenrod"),
       legend = c("Jackson","Larimer","Grand")) 


```

```{r}
scatterplotMatrix(~bio1+bio2+bio3+bio4, 
                 diagonal = "qqplot",
                 groups = phfo.bioclim.soils$County,
                 data=phfo.bioclim.soils,
                 reg.line=FALSE,
                 smoother="")

# most normally distributed: bio2, get rid of bio1, bio4, and bio3

scatterplotMatrix(~bio1+bio2+bio3+bio4, 
                 diagonal = "density",
                 groups = phfo.bioclim.soils$County,
                 data=phfo.bioclim.soils,
                 reg.line=FALSE,
                 smoother="")
```

```{r}
scatterplotMatrix(~bio5+bio2+bio6+bio7, 
                 diagonal = "density",
                 groups = phfo.bioclim.soils$County,
                 data=phfo.bioclim.soils,
                 reg.line=FALSE,
                 smoother="")

#Only keep 2: Mean Diurnal Range (Mean of monthly (max temp - min temp))
```
```{r}
scatterplotMatrix(~bio8+bio2+bio9+bio10, 
                 diagonal = "density",
                 groups = phfo.bioclim.soils$County,
                 data=phfo.bioclim.soils,
                 reg.line=FALSE,
                 smoother="")

#keep 2: Mean Diurnal Range (Mean of monthly (max temp - min temp))
#keep 9: Mean Temperature of Driest Quarter
```
```{r}
scatterplotMatrix(~bio11+bio2+bio9+bio12, 
                 diagonal = "density",
                 groups = phfo.bioclim.soils$County,
                 data=phfo.bioclim.soils,
                 reg.line=FALSE,
                 smoother="")

#keep 2: Mean Diurnal Range (Mean of monthly (max temp - min temp))
#keep 9: Mean Temperature of Driest Quarter
#keep 12: Annual Precipitation
```
```{r}
scatterplotMatrix(~bio15+bio2+bio9+bio12, 
                 diagonal = "density",
                 groups = phfo.bioclim.soils$County,
                 data=phfo.bioclim.soils,
                 reg.line=FALSE,
                 smoother="")

#keep 2: Mean Diurnal Range (Mean of monthly (max temp - min temp))
#keep 9: Mean Temperature of Driest Quarter
#keep 12: Annual Precipitation
#Keep 15: Precipitation Seasonality (Coefficient of Variation)
# precip bio16:19 all pretty highly correlated. 
```

Niche Overlap  
```{r}
phfo.prbg

library(foreach)
library(parallel)
library(doParallel)

library(magrittr) # pipe %>%

extent(typeall[[1]])

# r1 <- crop(bioclim.phfo[[1]], extent(typeall[[1]]))
# r <- disaggregate(r1, fact=10)
r <- raster(ncol=800, nrow=1250)
extent(r) <- extent(typeall[[1]])

# Raster out of the soil polygons
r.typeall <- lapply(1:4, function(i){
    out <- rasterize(typeall[[i]], r, field = typeall[[i]]@data[,6], fun = "mean", 
                         update = TRUE, updateValue = "NA")
    out
})

foo <- r.typeall

foo <- setNames(r.typeall, types )

writeRaster(stack(foo), "Q:/Research/All_Projects_by_Species/Phacelia SPECIES/Phacelia_formosula/Maxent_phfo/Soil_Maxent/soillayers.tif",  bylayer = TRUE, "GTiff")

plot(r.typeall[[1]]) 
# Might be too big, raster cells include all the Larimer points in one cell? 
# rasterstack <- stack(list(bioclim.phfo[[2]],bioclim.phfo[[9]],bioclim.phfo[[12]],bioclim.phfo[[15]]))

# stack the soil data
rasterstack <- stack(r.typeall)

# pathstart <- "Q:/Research/All_Projects_by_Species/Phacelia SPECIES/Phacelia_formosula/Maxent_phfo/"

pathstart <- "Q:/Research/All_Projects_by_Species/Phacelia SPECIES/Phacelia_formosula/Maxent_phfo/Soil_Maxent/"

plot(phfo.prbg[phfo.prbg$County == "Larimer",c("lon","lat")]) +
plot(r.typeall[[4]], add=TRUE) +
points(phfo.prbg[phfo.prbg$County == "Larimer",c("lon","lat")])
```


    
```{r}              
# Will try with specifying background points
for(rep in 1:10){
  
      phfo.prbg$kfold[phfo.prbg$County == "Larimer"] <- kfold(phfo.prbg[phfo.prbg$County == "Larimer",], 4)
      phfo.prbg$kfold[phfo.prbg$County == "Jackson"] <- kfold(phfo.prbg[phfo.prbg$County == "Jackson",], 4)
      
      write.csv(data.frame(phfo.prbg), paste(pathstart,"presence","Rep",rep,sep="")) # oops, but to see which points got what kfold number
      LarimerMaxEnt <- maxent(x = rasterstack, p = phfo.prbg[phfo.prbg$County == "Larimer",c("lon","lat")],
                              a = phfo.prbg[phfo.prbg$County == "background", c("lon","lat")], factors = 'layer.4') 
      
      JacksonMaxEnt <- maxent(x = rasterstack, p = phfo.prbg[phfo.prbg$County == "Jackson",c("lon","lat")],
                              a = phfo.prbg[phfo.prbg$County == "background", c("lon","lat")], factors = 'layer.4') 
      
      
      #register parallel computing backend      
      ncores <- detectCores()-1
      cl = parallel::makeCluster(ncores)
      doParallel::registerDoParallel(cl,ncores)
      
      #compute indices for data splitting
      rows = 1:nrow(rasterstack)
      split = sort(rows%%ncores)+1
          
              outnameL = paste(pathstart, "PredictLarimer",rep,sep="")
              outnameJ = paste(pathstart, "PredictJackson", rep, sep="")
              
              #perform the prediction on subsets of the predictor dataset
              foreach(i=unique(split), .combine=c)%dopar%{
                rows_sub = rows[split==i]
                sub = raster::crop(rasterstack,raster::extent(rasterstack, min(rows_sub), max(rows_sub), 
                                                              1, ncol(rasterstack)))
                raster::predict(sub, LarimerMaxEnt, filename=paste(outnameL,"Rep",rep,"slice",i,sep=""), overwrite=TRUE)
                raster::predict(sub, JacksonMaxEnt, filename=paste(outnameJ,"Rep",rep,"slice",i,sep=""), overwrite=TRUE)
              }
              
              eL <- evaluate(phfo.prbg[phfo.prbg$kfold==1 & phfo.prbg$County == "Larimer",c("lon","lat")], 
                             phfo.prbg[phfo.prbg$County == "background",c("lon","lat")], LarimerMaxEnt, rasterstack)
              save(eL, file= paste(outnameL,"replicate", rep,"evaluate.Rda", sep=""))
              
              eJ <- evaluate(phfo.prbg[phfo.prbg$kfold==1 & phfo.prbg$County == "Jackson",c("lon","lat")],
                             phfo.prbg[phfo.prbg$County == "background",c("lon","lat")], JacksonMaxEnt, rasterstack)
              save(eJ, file= paste(outnameJ,"replicate", rep,"evaluate.Rda", sep=""))      
              
              gc()
              stopCluster(cl)
             

}                
                
# Stich the 10 slices together
# stitchtogether <- function(whichones, pathstart, patternmatch, rasternames){

lapply(c("Jackson","Larimer"), function(i){
  gc()
  
  # pull all slices (11 here) and then stitch together
  lapply(1:10, function(k){
    patternmatch <- paste("Predict",i,k,"Rep", sep="")

    resultpath <- list.files(path = pathstart, 
                             pattern = paste(patternmatch,k,"slice",sep=""), 
                             full.names=TRUE)
    rastout <- lapply(resultpath, function(x){
      raster(x)
      })
    rastout$filename <- paste(pathstart,"ProbTiffCounty",i,"Rep",k,".tif", sep="")
    rastout$overwrite <- TRUE
    m <- do.call(merge, rastout)
  })

})

# check overlap of the 10 replicates of each

overlapsLarimer_Jackson <- lapply(1:10, function(x){
  r1 <- raster(paste(pathstart, "ProbTiffCountyLarimerRep",x,".tif",sep=""))
  r2 <- raster(paste(pathstart, "ProbTiffCountyJacksonRep",x,".tif",sep=""))
  d_out <- nicheOverlap(r1,r2,mask=FALSE, checkNegatives = FALSE, stat="D")
  d_out
  })

overlapsLarimer_Jackson_I <- lapply(1:10, function(x){
  r1 <- raster(paste(pathstart, "ProbTiffCountyLarimerRep",x,".tif",sep=""))
  r2 <- raster(paste(pathstart, "ProbTiffCountyJacksonRep",x,".tif",sep=""))
  d_out <- nicheOverlap(r1,r2,mask=FALSE, checkNegatives = FALSE, stat="I")
  d_out
  })

hist(do.call(c,overlapsLarimer_Jackson))

Equivalency <- nicheEquivalency(phfo.prbg[phfo.prbg$County == "Larimer",c("lon","lat")], 
                                phfo.prbg[phfo.prbg$County == "Jackson",c("lon","lat")],
                                rasterstack)  # default model is maxent, will do 99 randomizations
hist(Equivalency$null.distribution[,1], main="", xlab= "Schoener's D")
hist(Equivalency$null.distribution[,2], main="", xlab= "Warren's I")

save(Equivalency, file=paste(pathstart, "Equivalency.Rda", sep="" ))
save(overlapsLarimer_Jackson, file=paste(pathstart, "overlapL_J_SchoenersD.Rda", sep=""))
save(overlapsLarimer_Jackson_I, file=paste(pathstart, "overlapL_J_I.Rda", sep=""))

```





# PCoA for 
vegan  
  isoMDS - non-metric multidimentsional scaling
  

ade4 - alternative implementation of ordination methods
```{r}


```

metric scaling
```{r}


```



```{r, eval=FALSE}
plotin <- phfo.bioclim.soils[phfo.bioclim.soils$pHwater<100 &
                               phfo.bioclim.soils$AWS025<100,]



scatterplotMatrix(~bio12+AWS025+Dep2WatTbl+pHwater, 
                 diagonal = "density",
                 groups = plotin$County,
                 data=plotin,
                 reg.line=FALSE,
                 smoother="")


ggplot(plotin[complete.cases(plotin$Code) & plotin$County<4,], 
       aes(bio12,AWS025, colour=as.factor(County)))+
  geom_point()+
  geom_point(data=plotin[plotin$County=="background" &
                           complete.cases(plotin$Code),],
                         aes(bio12,AWS025), alpha=0.25)+
  theme_bw()

```
Plot with density of each type, background, three counties on margins
```{r}
xhist_bio12 <- lapply(1:4, function(x){
  histout <- hist(plotin$bio12[complete.cases(plotin$Code) & 
                                 plotin$County == x],plot=FALSE)
  histout
})

plot(plotin$bio12[complete.cases(plotin$Code) & plotin$County<4,],
     plotin$AWS025[complete.cases(plotin$Code) & plotin$County<4,])
```


```{r}
#Turn all three counties in presence = 1 and all background of all three into absent = 0
phfo.bioclim.soils$prab <- 1
phfo.bioclim.soils$prab[phfo.bioclim.soils$County<4] <- 0
m1 <- glm(prab~bio15+bio2+bio9+bio12, data=phfo.bioclim.soils)
summary(m1)

m2 <- glm(prab~., data=phfo.bioclim.soils[,c(44,21:39)]) #only the bioclim columns

modelpredic <- predict(m1, phfo.bioclim.soils[,c("bio15","bio2","bio9","bio12")])
#From example presvals == phfo.bioclim.soils[phfo.bioclim.soils$County<4,21:39]
bc <- bioclim(phfo.bioclim.soils[phfo.bioclim.soils$County<4,
                                 c("bio15","bio2","bio9","bio12")])

response(bc)
```

```{r}
names(bioclim.phfo)
predictors <- stack(bioclim.phfo[[c(2,9,12,15)]])
names(predictors) <- c("bio2","bio9","bio12","bio15")


p<- predict(predictors, m1)
plot(p)
plot(ph.counties, add=TRUE)
```



```{r}

layout.show(layout(matrix(c(7,1,2,3,
                11,8,4,5,
                12,13,9,6,
                14,15,16,10), 4,4,byrow = TRUE)))
```

layoutbioplot <- function(x){ #a vector of climate and/or soil columns from biodata
  rowcols <- length(x)
  uppertri <- sum(seq(rowcols-1,1))
  lowertri <- uppertri+rowcols+1
}
layout(matrix(c(
  uppertri+1,1:rowcols-1,
  uppertri+2,rowcols:rowcols+1,
  uppertri+3,)),
       rowcols,rowcols,byrow=TRUE))

for(i in 4:6){
  par(mai = c(1,1,1,1)/4)
  plot(biodata[,i],biodata[,3],col=biodata$phfo.UTM.Code,
       xaxt="n")
}
for(i in 5:6){
  par(mai = c(1,1,1,1)/4)
  plot(biodata[,i],biodata[,4],col=biodata$phfo.UTM.Code,
       xaxt="n")
}
par(mai = c(1,1,1,1)/4)
plot(biodata[,6],biodata[,5], col=biodata$phfo.UTM.Code,
       xaxt="n")
for(i in 3:6){
  hist(biodata[,i], main="")
  rug(biodata[,i])
}

Meaningless, no differences  
# 2 bio12+Dep2WatTbl, then: pHwater
plot(phfo.bioclim.soils$bio12[phfo.bioclim.soils$County<4 &
                                phfo.bioclim.soils$Dep2WatTbl>100],
     phfo.bioclim.soils$Dep2WatTbl[phfo.bioclim.soils$County<4 &
                                     phfo.bioclim.soils$Dep2WatTbl>100],
     col=phfo.bioclim.soils$County[phfo.bioclim.soils$County<4&
                                  phfo.bioclim.soils$Dep2WatTbl>100],
     pch=16, axes=FALSE, ylab="", xlab="") 
#"Avaliable Surface Water (0-25cm)",xlab="Annual Precipitation")
axis(side=4,las=1)
points(phfo.bioclim.soils$bio12[phfo.bioclim.soils$County=="background" &
                                  phfo.bioclim.soils$Dep2WatTbl>100],
     phfo.bioclim.soils$Dep2WatTbl[phfo.bioclim.soils$County=="background" &
                                     phfo.bioclim.soils$Dep2WatTbl>100],
     pch=16, cex=2,
     col=rgb(1,0.5,0,0.05))
     
     
```{r}
#plot function with layout
layout(matrix(c(7,1,2,3,
                11,8,4,5,
                12,13,9,6,
                14,15,16,10), 4,4,byrow = TRUE))

# 1 annual precip bio12 to AWS025
phfo.bioclim.soils_sm <- phfo.bioclim.soils[phfo.bioclim.soils$AWS025<100,]
plot(phfo.bioclim.soils_sm$bio12[phfo.bioclim.soils_sm$County<4],
     phfo.bioclim.soils_sm$AWS025[phfo.bioclim.soils_sm$County<4],
     col=phfo.bioclim.soils_sm$County[phfo.bioclim.soils_sm$County<4],
     pch=16, axes=FALSE, ylab="", xlab="") 
#"Avaliable Surface Water (0-25cm)",xlab="Annual Precipitation")
axis(side=3,las=1)
points(phfo.bioclim.soils_sm$bio12[phfo.bioclim.soils_sm$County=="background"],
     phfo.bioclim.soils_sm$AWS025[phfo.bioclim.soils_sm$County=="background"],
     pch=16, cex=2,
     col=rgb(1,0.5,0,0.05))

# 2 annual precip to phwater
plot(phfo.bioclim.soils_sm$bio12[phfo.bioclim.soils_sm$County<4],
     phfo.bioclim.soils_sm$pHwater[phfo.bioclim.soils_sm$County<4],
     col=phfo.bioclim.soils_sm$County[phfo.bioclim.soils_sm$County<4],
     pch=16, axes=FALSE, ylab="", xlab="") 
#"Avaliable Surface Water (0-25cm)",xlab="Annual Precipitation")
axis(side=3,las=1)
points(phfo.bioclim.soils_sm$bio12[phfo.bioclim.soils_sm$County=="background"],
     phfo.bioclim.soils_sm$pHwater[phfo.bioclim.soils_sm$County=="background"],
     pch=16, cex=2,
     col=rgb(1,0.5,0,0.05))



```

```{r, eval=FALSE}
#Should keep only not correltated ones
cor.table <- cor(biodata[,3:length(biodata)])
data <- as.data.frame(as.table(cor.table))
combns <- combn(colnames(cor.table),2,FUN=function(x) paste(x,collapse = "_"))
cor.data <- data[data$Var1 != data$Var2, ]
data <- cor.data[paste(cor.data$Var1, cor.data$Var2, sep="_") %in% combns,]
head(data)

data[data$Var1 == "bio1.ph" & data$Freq > 0.7,]
data[data$Var2 == "bio1.ph"& data$Freq > 0.7,]
data[data$Freq > 0.7,]

# Keep only annual precipitation
data <- data[data$Var1 != "bio19.ph" & data$Var2 != "bio19.ph",]
data <- data[data$Var1 != "bio18.ph" & data$Var2 != "bio18.ph",]
data <- data[data$Var1 != "bio17.ph" & data$Var2 != "bio17.ph",]
data <- data[data$Var1 != "bio16.ph" & data$Var2 != "bio16.ph",]
data <- data[data$Var1 != "bio15.ph" & data$Var2 != "bio15.ph",]
data <- data[data$Var1 != "bio14.ph" & data$Var2 != "bio14.ph",]
data <- data[data$Var1 != "bio13.ph" & data$Var2 != "bio13.ph",]

# If keep bio12: get rid of bio3 (Isothermality), keep annual mean temp (1)
data <- data[data$Var1 != "bio3.ph" & data$Var2 != "bio3.ph",]
data <- data[data$Var1 != "bio10.ph" & data$Var2 != "bio10.ph",]
data <- data[data$Var1 != "bio8.ph" & data$Var2 != "bio8.ph",]

# Keep bio2: mean diurnal range, get rid of 4,5,and 7
data <- data[data$Var1 != "bio4.ph" & data$Var2 != "bio4.ph",]
data <- data[data$Var1 != "bio5.ph" & data$Var2 != "bio5.ph",]
data <- data[data$Var1 != "bio7.ph" & data$Var2 != "bio7.ph",]

#Either keep min temp of coldest month (6) or quarter (11)
data <- data[data$Var1 != "bio11.ph" & data$Var2 != "bio11.ph",]

names(biodata[,c(30,38,41,44,48)])
pairs(biodata[,c(30,38,41,44,48)])

bio.dist <- dist(biodata[,c(30,38,41,44,48)], method="manhattan") 

bio.prcomp <- prcomp(biodata[,c(30,38,41,44,48)], center = TRUE)
print(bio.prcomp)
summary(bio.prcomp)

plot.bio <- data.frame(biodata,bio.prcomp$x)

populations <- unique(plot.bio$Population)
plot.bio$Species <- "phsc"
plot.bio$Species[plot.bio$Population %in% paste(populations[c(1:3,5:7,11:15)],sep="|")] <- "phfo"
plot.bio$Species[plot.bio$Population == populations[4]] <- "phgi"


ggplot(plot.bio, aes(PC1,PC2, colour=Population))+
  geom_point()+
  theme_bw()


ggplot(plot.bio, aes(PC1,PC2, colour=Species))+
  geom_point()+
  theme_bw()

## try with princomp
bionames <- names(biodata[,c(30,38,41,44,48)])

pairs(biodata[,c(30,38,41,44,48)])
keep <- c(30,38,41,44,48)
      
ph.pca <- princomp(biodata[,keep], cor=TRUE)
summary(ph.pca)
asmi.load <- loadings(ph.pca) #1: Annual Mean Temperature, 11: Mean temp of coldest quarter, 9: Mean temp of driest quarter


plot.pca <- data.frame(ph.pca$scores, plot.bio)

ggplot(plot.pca, aes(Comp.1,Comp.2,colour = Species))+
  geom_point()+
  theme_bw()

ggplot(plot.bio, aes(bio6.ph, bio2.ph, colour = Species))+
  geom_point()+
  labs(x = "Min Temperature of Coldest Month", 
       y = "Mean Diurnal Range (Mean of monthly (max temp - min temp))")+
#  geom_polygon(aes(fill = Species), alpha = 0.3)+
  theme_bw()


ggplot(plot.bio, aes(bio1.ph, bio9.ph, colour = Species))+
  geom_point()+
  labs(x = "Annual mean temperature", y = "Mean temperature of driest quarter")+
  theme_bw()

ggplot(plot.bio, aes(bio1.ph, bio12.ph, colour = Species))+
  geom_point()+
  labs(x = "Annual mean temperature", y = "Annual Precipitation")+
  theme_bw()


# summer and winter moisture... 
ggplot(plot.bio, aes(bio18.ph, bio19.ph, colour = Species))+
  geom_point()+
  theme_bw()


ggplot(plot.bio, aes(bio11.ph, bio9.ph, colour = Species))+
  geom_point()+
  labs(x = "Mean temperature of coldest quarter", y = "Mean temperature of driest quarter")+
  theme_bw()

ggplot(plot.bio, aes(bio11.ph, bio9.ph, colour = Species))+
  geom_point()+
  labs(x = "Mean temperature of coldest quarter", y = "Mean temperature of driest quarter")+
  theme_bw()

ggplot(plot.bio, aes(bio14.ph, bio19.ph, colour = Species))+
  geom_point()+
  labs(x = "Precipitation of Driest Month", y = "Precipitation of Coldest Quarter")+
  theme_bw()

ggplot(plot.bio, aes(bio6.ph, bio19.ph, colour = Species))+
  geom_point()+
  labs(x = "Min Temperature of Coldest Month", y = "Precipitation of Coldest Quarter")+
  theme_bw()

unique(plot.bio$MUSYM)
unique(plot.bio$MUKIND)
unique(plot.bio$MUKEY)

ggplot(plot.bio, aes(MUSYM, bio12.ph, colour = Species))+
  geom_violin()+
  geom_point()+
  labs(x= "Soil Type", y = "Annual Precipitation")+
  theme_bw()


#Which are correlated? 
data[abs(data$Freq)>0.75,]

# Use daisy to combine bioclim and soil


```

