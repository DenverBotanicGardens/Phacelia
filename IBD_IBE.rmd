---
title: "IBD"
author: "Michelle DePrenger-Levin"
date: "November 17, 2016"
output: html_document
---

Climate envelope

Nov17PhFo_data_all2loci... in case I need the genetic data again

```{r}
rm(list=ls())
```

<http://rfunctions.blogspot.com/2016/10/simple-and-partial-mantel-tests.html>    
<http://dr-k-lo.blogspot.com/2012/04/how-to-do-mantel-test-in-r.html>     
<http://adegenet.r-forge.r-project.org/files/tutorial-basics.pdf>     

```{r, warning=FALSE, message=FALSE}
library(raster)
library(rgdal)
library(maptools)
library(devtools)
library(vegan)
library(MASS)
library(prism)
library(dismo)
library(ggplot2)
#library(Imap)
#library(wordcloud)
library(MASS)
library(adegenet)
#library(pegas)
library(ape)
library(ade4)
library(ggmap)
library(vegan)
library(boot)
#library(ecodist)
library(geosphere)
#library(poppr)
# library(car)
#library(strataG)
library(rgeos)
#library(diveRsity)
library(ggmap)
library(hierfstat)
library(sp)

```

Pairwise distance matrix
```{r}
ph.dist <- read.csv("Q:/Research/Lab/Projects/Phacelia formosula/Project Information/Phacelia project information with GPS centroids 2016_pdm.csv")

# Get rid of TC
ph.dist1 <- ph.dist[ph.dist$Code != "T",]

#Convert the Northing/Easting to lat/long
ph.dist.UTM <- SpatialPoints(ph.dist[,c("Easting","Northing")],
                        proj4string = CRS("+proj=utm +zone=13 +datum=NAD83"))
ph.dist.LatLon <- spTransform(ph.dist.UTM, CRS("+proj=longlat +datum=WGS84"))
ph.dist <- data.frame(ph.dist,ph.dist.LatLon)
plot(ph.dist.LatLon) # 3 counties

ph.dist1.UTM <- SpatialPoints(ph.dist1[,c("Easting","Northing")],
                        proj4string = CRS("+proj=utm +zone=13 +datum=NAD83"))
ph.dist1.LatLon <- spTransform(ph.dist1.UTM, CRS("+proj=longlat +datum=WGS84"))
ph.dist1 <- data.frame(ph.dist1,ph.dist1.LatLon)
plot(ph.dist1.LatLon) # 2 counties

#These are just populations, not individuals
identical(ph.dist[-15,],ph.dist1) # TRUE
spatialdist1.noTC <- dist(ph.dist1[,3:4]) # Northing, Easting is in UTM, Easting.1 == Lon; Northing.1 == Lat

spatialdist.noTC <- dist(ph.dist[-15,3:4]) #exclude Troublesome Creek
spatialdist.TC <- dist(ph.dist[,3:4])

spatialdist1.noTC;spatialdist.noTC
identical(spatialdist1.noTC,spatialdist.noTC) # They look the same but are somehow different

# from DAPC and <http://adegenet.r-forge.r-project.org/files/tutorial-basics.pdf>


#Dgeo <- spatialdist.noTC

# ggmap is all broken
# ggmap(get_map(c(-107,40,-105.25,41)))+
#   geom_point(data=ph.dist, aes(Easting.1,Northing.1))

```

spatial Analysis of principal components (sPCA) complements classical PCA retrieving non-trivial spatial genetic patterns   
Spatial and genetic data per individual -> don't want by individual Jan 26, 2018  
  - Thibaut in his vignette for adegenet says you can do isotlation by 
```{r}
# Genepop input file with PhGi (TC) 431 individuals
phall <- read.genepop("C:/Users/deprengm/Dropbox/Denver Botanic Gardens Postdoctoral Genetic Files/Phacelia project/Manuscript/GenAlExAnalyses_Nov2017/Genpop_PhfoData_Nov2017.gen") # Nov2017... PhfoData.. 6Dec2017 does not have troublesome creek. 

table(phall@pop)
#Change to match T -> TC; F -> FC; B -> BR
currentlevels <- levels(phall@pop)
currentlevels[currentlevels=="T"] <- "TC"
currentlevels[currentlevels=="F"] <- "FC"
currentlevels[currentlevels=="B"] <- "BR"
currentlevels[currentlevels=="D"] <- "DJ"
currentlevels[currentlevels=="P"] <- "PW"
currentlevels[currentlevels=="R"] <- "RW"
currentlevels[currentlevels=="V"] <- "VR"
levels(phall@pop) <- currentlevels

# GENIND with no Troublesome Creek !!
ph1 <- phall[phall@pop != "TC"] #395 individuals
table(ph1@pop)


# Can store spatial information in @other$xy  
# Location information for each individual under Northing/Easting (need lat/lon) for individuals as $Code AN... and $Ind. 1:30 
phfo.gen <- read.csv("Q:/Research/Lab/Projects/Phacelia formosula/Project Information/Phacelia project information with GPS data 2016_all.csv")

nrow(phfo.gen) #451 - some individuals were thrown out for the genetic data.
codelevels <- levels(phfo.gen$Code)
codelevels[codelevels=="D"] <- "DJ"
codelevels[codelevels=="P"] <- "PW"
codelevels[codelevels=="R"] <- "RW"
codelevels[codelevels=="V"] <- "VR"
levels(phfo.gen$Code) <- codelevels
table(phfo.gen$Code)
phfo.gen$Code <- factor(phfo.gen$Code, levels=levels(phall@pop))


phfo.indloc <- read.csv("C:/Users/deprengm/Dropbox/Denver Botanic Gardens Postdoctoral Genetic Files/Phacelia project/Manuscript/GenAlExAnalyses_Nov2017/LatLon_PhfoData_Nov2017.csv")

table(phfo.indloc$SimpleCode)
curlev <- levels(phfo.indloc$SimpleCode)
curlev[curlev=="T"] <- "TC"
curlev[curlev=="F"] <- "FC"
curlev[curlev=="B"] <- "BR"
curlev[curlev=="D"] <- "DJ"
curlev[curlev=="P"] <- "PW"
curlev[curlev=="R"] <- "RW"
curlev[curlev=="V"] <- "VR"
levels(phfo.indloc$SimpleCode) <- curlev

phfo.gen1 <- phfo.gen[!grepl("TC",phfo.gen$Code),]
phfo.indloc1 <- phfo.indloc[!grepl("TC",phfo.indloc$SimpleCode),]
#Still match these locaitons with the individuals from phall
table(phall@pop)
table(phfo.gen$Code) # Has Troublesome Creek
table(ph1@pop)
table(phfo.indloc$SimpleCode) # Has Troublesome Creek
table(phfo.gen1$Code) # Zero TC
table(phfo.indloc1$SimpleCode) # Zero TC


```

```{r}
# help make levels match?
# phfo.indloc$SimpleCode <- factor(phfo.indloc$SimpleCode, levels= levels(phall@pop))
# table(phfo.indloc$SimpleCode)

#Morphology  
phfo.loc <- read.csv("C:/Users/deprengm/Dropbox/Denver Botanic Gardens Postdoctoral Genetic Files/Phacelia project/Phacelia 2014 collection and morphology data/geoloc_ph.csv")
table(phfo.loc$Population.Code) #only collections from FC, RN, BR, AS, and TC

phfo.loc$Population.Code <- factor(phfo.loc$Population.Code, levels=levels(phall@pop))
table(phall@pop)
table(phfo.indloc$SimpleCode)

#phall are individuals from phfo.indloc
# So take the SimpleCode and IndNum from phfo.indloc and the Northing and Easting from phfo.gen matching Code and Ind.
# phfo.gen$Code <- as.character(phfo.gen$Code)
# phfo.indloc$SimpleCode <- as.character(phfo.indloc$SimpleCode)


#Want to keep order of phall which might come from phfo.indloc
phfo.indloc$ID <- 1:nrow(phfo.indloc)
phfo.UTM <- merge(phfo.gen,phfo.indloc[,c(1,3:5)],
                  by.x=c("Code","Ind."),by.y=c("SimpleCode","IndNum"))

#Same without TC
phfo.indloc1$ID <- 1:nrow(phfo.indloc1)
phfo.UTM1 <- merge(phfo.gen1,phfo.indloc1[,c(1,3:5)],
                  by.x=c("Code","Ind."),by.y=c("SimpleCode","IndNum"))


#Back to phfo.indloc order
phfo.UTM <- phfo.UTM[with(phfo.UTM, order(phfo.UTM$ID)),]
phfo.UTM$Code <- factor(phfo.UTM$Code, levels=levels(phall@pop))
table(phfo.UTM$Code)
sum(table(phfo.UTM$Code)) #425


phfo.UTM1 <- phfo.UTM1[with(phfo.UTM1, order(phfo.UTM1$ID)),]
phfo.UTM1$Code <- factor(phfo.UTM1$Code, levels=levels(ph1@pop))
table(phfo.UTM1$Code)
sum(table(phfo.UTM1$Code)) #395


#Convert phfo.UTM$Easting and $Northing to lat/lon
phfo.UTM.SP <- SpatialPoints(phfo.UTM[,c("Easting","Northing")],
                        proj4string = CRS("+proj=utm +zone=13 +datum=NAD83"))
phfo.LatLon <- spTransform(phfo.UTM.SP, CRS("+proj=longlat +datum=WGS84"))
phfo.UTM <- data.frame(phfo.UTM,phfo.LatLon)
names(phfo.UTM) <- c(names(phfo.UTM)[-c((length(phfo.UTM)-1):length(phfo.UTM))],"lon","lat")

# Version without TC
phfo.UTM.SP1 <- SpatialPoints(phfo.UTM1[,c("Easting","Northing")],
                        proj4string = CRS("+proj=utm +zone=13 +datum=NAD83"))
phfo.LatLon1 <- spTransform(phfo.UTM.SP1, CRS("+proj=longlat +datum=WGS84"))
phfo.UTM1 <- data.frame(phfo.UTM1,phfo.LatLon1)
names(phfo.UTM1) <- c(names(phfo.UTM1)[-c((length(phfo.UTM1)-1):length(phfo.UTM1))],"lon","lat")

#Want XY coordinates from phfo.gen that are individuals found in gen.ind
phall@other$xy <- phfo.UTM[,c("lon","lat")]
identical(phfo.UTM[-grep("TC",phfo.UTM$Code),c("lon","lat")],phfo.UTM1[,c("lon","lat")])
phfo.UTM[-grep("TC",phfo.UTM$Code),c("lon","lat")];phfo.UTM1[,c("lon","lat")] # not idendical but look the same?!?!
# ph1@other$xy <- phfo.UTM[-grep("TC",phfo.UTM$Code),c("lon","lat")]
ph1@other$xy <- phfo.UTM1[,c("lon","lat")]
nrow(phall@other$xy) #425
nrow(ph1@other$xy) # 395
```


With TC
Get distance matrix for genetic distance by population (15)
```{r}
Dgen <- dist.genpop(genind2genpop(phall), method=1) #1: Nei's 2: Angular Edward's Euclidean distance
Dgenind <- dist(phall@tab) #euclidean
Dgenind.maximum <- dist(phall@tab, method="max")
# Dgeo <- dist(phall$other$xy)
Dgeo <- dist(phfo.UTM[,c("Easting","Northing")])
#These are the genetic and geographic distance for 425 individuals
ibd <- mantel.randtest(Dgenind,Dgeo) #OH dear, Dgen is 15 populations, Dgeo are all individuals
ibd

plot(ibd)

ibdmax <- mantel.randtest(Dgeo,Dgenind.maximum)
ibdmax

vegan::mantel(Dgeo,Dgenind)

#vegan version
vegan::mantel(Dgeo,Dgenind, permutations = 9999)

#Distance with UTM is now in meters, distance of lat/lon are who knows
plot(density(Dgeo), main = "Distance of geo, red = log transformed") # xlim=c(-11,11), 


#similar "rank"?

determinant(as.matrix(Dgenind), logarithm = TRUE)
eigens <- eigen(as.matrix(Dgenind)) #the variance
plot(density(eigens$values), main="variance")
points(max(eigens$values),0.1) #2757.032 that's some crazy variance
```

Takes very long time, that's why output saved
strataG
```{r, eval=FALSE}
gtypes_phfo <- genind2gtypes(phall)

#
Hstats(gtypes_phfo)

output_pw_phfo <- pairwiseTest(gtypes_phfo)

output_pw_phfo$pair.mat$`G''st`

#Fst(phall, pop=phall@pop)
save(output_pw_phfo, file="P:/hackathon/Phacelia/output_pw_phfo.rda")

```

```{r}
load("P:/hackathon/Phacelia/output_pw_phfo.rda")

colnums <- c()
for(i in 2:425){
  colnums <- c(colnums,i:425)
}

colslabels <- phall@pop[c(colnums)]
firstones <- rle(as.numeric(colslabels)) #want to label once for each group
labelonce <- apply(do.call(cbind,firstones),1,FUN=function(x){
  label<-x[2]
  NAs<-rep(NA,x[1]-1)
  c(label,NAs)   #if it's by down each column?
})
labels <- do.call(c,labelonce)
str(as.numeric(labels))

labels2 <- labels 
labels2[426:(length(labels2))] <- NA

labels3 <- labels2
labels3 <- levels(phall@pop)[labels3]

plot(jitter(Dgeo),Dgenind, col=colslabels,pch=as.numeric(colslabels), cex=0.75) #the lower triangle by lower triangle
text(Dgeo,jitter(rep(1,length(Dgenind)),factor=15), 
     labels=labels3, cex=0.75, col=labels2)
abline(lm(Dgenind~Dgeo))
#legend("bottomright", legend = unique(phall@pop), col=as.numeric(labels2),pch=16)

summary(lm(Dgenind~Dgeo))

plot(lm(Dgenind~Dgeo))
#KS goodness of fit test, low probability that the genetic and geographic distance matrices are the same distribution. 
ks.test(Dgenind, Dgeo)
ks.test(Dgeo, plnorm)
ks.test(Dgenind, plnorm)
ks.test(Dgenind, punif)

```

```{r}
'%ni%' <- Negate('%in%')

phGrand <- phall[phall@pop == "TC"] #30
phJackson <- phall[!(phall@pop %in% c("FC","HN","HS","TC"))] #330
phLarimer <- phall[(phall@pop %in% c("FC","HN","HS"))] #65

# phJacksonandLarimer <- phall[phall@pop != "TC"]
phJacksonandLarimer <- ph1


Dgenind_Grand <- dist(phGrand@tab)
Dgenind_Jackson <- dist(phJackson@tab)
Dgenind_Larimer <- dist(phLarimer@tab)

Dgeo_Grand <- dist(phfo.UTM[grepl("TC",phfo.UTM$Code),c("Easting","Northing")])
Dgeo_Jackson <- dist(phfo.UTM[phfo.UTM$Code %ni% c("FC","HN","HS","TC"),c("Easting","Northing")])
Dgeo_Larimer <- dist(phfo.UTM[phfo.UTM$Code %in% c("FC","HN","HS"),c("Easting","Northing")])

Dgeo_JacksonandLarimer <- dist(phfo.UTM1[,c("Easting","Northing")])

# Lat/Lon
# Dgeo_Grand <- dist(phGrand$other$xy)
# Dgeo_Jackson <- dist(phJackson$other$xy)
# Dgeo_Larimer <- dist(phLarimer$other$xy)

Dgenind_JacksonandLarimer <- dist(phJacksonandLarimer@tab)

#hierfstat:: 
Grand.hf <- genind2hierfstat(phGrand)
#Grand.dist.hf <- varcomp.glob(Grand.hf$pop, Grand.hf[,-1]) #nope, only one population
Jackson.hf <- genind2hierfstat(phJackson)
Jackson.dist.hf <- varcomp.glob(Jackson.hf,Jackson.hf[,-1] ) # ???


matFst <- pairwise.fst(phall)
matFst1 <- pairwise.fst(ph1)

plot(phall$other$xy$lon,phall$other$xy$lat)
points(phGrand$other$xy$lon,phGrand$other$xy$lat, col="red", cex=2)
points(phJackson$other$xy$lon,phJackson$other$xy$lat, col="blue", cex=1.5)
points(phLarimer$other$xy$lon,phLarimer$other$xy$lat, col="green", cex=2)
points(phJacksonandLarimer$other$xy$lon,phJacksonandLarimer$other$xy$lat, col="purple", cex=5)


plot(ph1$other$xy$lon,ph1$other$xy$lat)
# points(phGrand$other$xy$lon,phGrand$other$xy$lat, col="red", cex=2)
points(phJackson$other$xy$lon,phJackson$other$xy$lat, col="blue", cex=1.5)
points(phLarimer$other$xy$lon,phLarimer$other$xy$lat, col="green", cex=2)
points(phJacksonandLarimer$other$xy$lon,phJacksonandLarimer$other$xy$lat, col="purple", cex=5)
```

# With Grand County, Troublesome Creek, skip to next for no TC
```{r}
layout(matrix(c(2,3,5,
                4,1,6),2,3,byrow=TRUE))

#plot 1
par(mar=c(2,4.5,4.5,0.5))
dens <-kde2d(Dgeo,Dgenind, n=100)
myPal <- colorRampPalette(c("white","blue","gold", "orange", "red"))
plot(Dgeo, Dgenind, pch=20,cex=.5, xlim=c(0,1),ylim=c(0,10), ylab="", xlab="meters")
image(dens, col=transp(myPal(300),.7), add=TRUE)
abline(lm(Dgenind~Dgeo))
title("Isolation by distance plot")

#plot 2
par(mar=c(1,4.5,4.5,0.5))
dens <-kde2d(Dgeo_Jackson,Dgenind_Jackson, n=100)
myPal <- colorRampPalette(c("white","blue","gold", "orange", "red"))
plot(Dgeo_Jackson, Dgenind_Jackson, pch=20,cex=.5, xlab="",ylab="Euclidean distance")
image(dens, col=transp(myPal(300),.7), add=TRUE)
abline(lm(Dgenind_Jackson~Dgeo_Jackson))
title("Jackson County")

#plot 3
par(mar=c(1,4.5,4.5,0.5))
dens <-kde2d(Dgeo_Larimer,Dgenind_Larimer, n=100)
myPal <- colorRampPalette(c("white","blue","gold", "orange", "red"))
plot(Dgeo_Larimer, Dgenind_Larimer, pch=20,cex=.5, xlab="",ylab="")
image(dens, col=transp(myPal(300),.7), add=TRUE)
abline(lm(Dgenind_Larimer~Dgeo_Larimer))
title("Larimer County")

#plot 4
par(mar=c(2,4.5,4.5,0.5))
dens <-kde2d(Dgeo_Grand,Dgenind_Grand, n=100)
myPal <- colorRampPalette(c("white","blue","gold", "orange", "red"))
plot(Dgeo_Grand, Dgenind_Grand, pch=20,cex=.5, xlab="meters",ylab="Euclidean distance" )
image(dens, col=transp(myPal(300),.7), add=TRUE)
abline(lm(Dgenind_Grand~Dgeo_Grand))
title("Grand County")

#plot 5
par(mar=c(2,4.5,4.5,0.5))
dens <-kde2d(Dgeo_JacksonandLarimer,Dgenind_JacksonandLarimer, n=300)
myPal <- colorRampPalette(c("white","blue","gold", "orange", "red"))
plot(Dgeo_JacksonandLarimer, Dgenind_JacksonandLarimer, pch=20,cex=.5, xlab="meters",ylab="Euclidean distance" )
image(dens, col=transp(myPal(300),.7), add=TRUE)
abline(lm(Dgenind_JacksonandLarimer~Dgeo_JacksonandLarimer))
title("Jackson and Larimer County")

#plot 6
plot(phall$other$xy$lon,phall$other$xy$lat)
points(phGrand$other$xy$lon,phGrand$other$xy$lat, col="red", cex=2)
points(phJackson$other$xy$lon,phJackson$other$xy$lat, col="blue", cex=1.5)
points(phLarimer$other$xy$lon,phLarimer$other$xy$lat, col="green", cex=2)
points(phJacksonandLarimer$other$xy$lon,phJacksonandLarimer$other$xy$lat, col="purple", cex=5)
```

# Get rid of TC
```{r}
Dgen1 <- dist.genpop(genind2genpop(ph1), method=1) #1: Nei's 2: Angular Edward's Euclidean distance
Dgenind1 <- dist(ph1@tab) #euclidean
Dgenind.maximum1 <- dist(ph1@tab, method="max")
Dgeo1 <- dist(ph1$other$xy)

```

```{r}
jpeg("C:/Users/deprengm/Dropbox/Denver Botanic Gardens Postdoctoral Genetic Files/Phacelia project/Manuscript/Figures/Isolationxdistxgen.jpg",
     width=150, height=125,units='mm', res=300)

layout(matrix(c(1,2,
                3,4),2,2,byrow=TRUE))

#plot 1
par(mar=c(2,4.5,4.5,0.5)+0.1)
dens1 <-kde2d(Dgeo1,Dgenind1, n=100)
myPal <- colorRampPalette(c("white","blue","gold", "orange", "red"))
plot(Dgeo1, Dgenind1, pch=20,cex=.5, xlim=c(0,1),ylim=c(0,10), ylab="Genetic Distance (Euclidean)", xlab="meters")
image(dens1, col=transp(myPal(300),.7), add=TRUE)
abline(lm(Dgenind1~Dgeo1))
title("Isolation by distance plot")

#plot 2
par(mar=c(1,4.5,4.5,0.5))
dens <-kde2d(Dgeo_Jackson,Dgenind_Jackson, n=100)
myPal <- colorRampPalette(c("white","blue","gold", "orange", "red"))
plot(Dgeo_Jackson, Dgenind_Jackson, pch=20,cex=.5, xlab="",ylab="Euclidean distance")
image(dens, col=transp(myPal(300),.7), add=TRUE)
abline(lm(Dgenind_Jackson~Dgeo_Jackson))
title("Jackson County")

#plot 3
par(mar=c(1,4.5,4.5,0.5))
dens <-kde2d(Dgeo_Larimer,Dgenind_Larimer, n=100)
myPal <- colorRampPalette(c("white","blue","gold", "orange", "red"))
plot(Dgeo_Larimer, Dgenind_Larimer, pch=20,cex=.5, xlab="",ylab="")
image(dens, col=transp(myPal(300),.7), add=TRUE)
abline(lm(Dgenind_Larimer~Dgeo_Larimer))
title("Larimer County")

#plot 4
par(mar=c(2,4.5,4.5,0.5))
dens <-kde2d(Dgeo_Grand,Dgenind_Grand, n=100)
myPal <- colorRampPalette(c("white","blue","gold", "orange", "red"))
plot(Dgeo_Grand, Dgenind_Grand, pch=20,cex=.5, xlab="meters",ylab="Euclidean distance" )
image(dens, col=transp(myPal(300),.7), add=TRUE)
abline(lm(Dgenind_Grand~Dgeo_Grand))
title("Grand County")

#plot 5
par(mar=c(2,4.5,4.5,0.5))
dens <-kde2d(Dgeo_JacksonandLarimer,Dgenind_JacksonandLarimer, n=300)
myPal <- colorRampPalette(c("white","blue","gold", "orange", "red"))
plot(Dgeo_JacksonandLarimer, Dgenind_JacksonandLarimer, pch=20,cex=.5, xlab="meters",ylab="Euclidean distance" )
image(dens, col=transp(myPal(300),.7), add=TRUE)
abline(lm(Dgenind_JacksonandLarimer~Dgeo_JacksonandLarimer))
title("Jackson and Larimer County")

#plot 6
plot(phall$other$xy$lon,phall$other$xy$lat)
points(phGrand$other$xy$lon,phGrand$other$xy$lat, col="red", cex=2)
points(phJackson$other$xy$lon,phJackson$other$xy$lat, col="blue", cex=1.5)
points(phLarimer$other$xy$lon,phLarimer$other$xy$lat, col="green", cex=2)
points(phJacksonandLarimer$other$xy$lon,phJacksonandLarimer$other$xy$lat, col="purple", cex=5)
```

. ** Suggestion is a "partial Mantel testing association between the matrix of genetic distances, a model matrix of cluster membership, with matrix of geographical distances as a covariate** However, with a barrier, this test is not conservative, will still claim isolation by distance (when there is none). 

Simluations of IBD
```{r}
simulation <- "phfo_1530indiv"
sim_filenames <- list.files("Q:/Research/Stats & Software/EasyPOP")
phfo_15 <- sim_filenames[grep(simulation, sim_filenames)]
phfo_15 <- phfo_15[grep(".gen", phfo_15)]

genepop_sims <- list()
for(i in 1:(length(phfo_15))){
  #print(paste("Q:/Research/Stats & Software/EasyPOP/",
   #                                       phfo_15[i],
    #                                      sep=""))
  genepop_sims[[i]] <- read.genepop(paste("Q:/Research/Stats & Software/EasyPOP/",
                                          phfo_15[i],
                                          sep=""))
}

# So now can do measurements on this list
genepop_sims[[1]] # 15,000 individuals; 12 loci; 71 alleles; size: 5 Mb
phall #425 individuals; 12 loci; 113 alleles; size: 243.5 Kb

dist_sim <- list()
for(i in 1:(length(genepop_sims))){
  dist_sim[[i]] <- dist(genepop_sims[[i]][floor(runif(425, 1,450))]) #want 425 indiviuals to match
}


ibd_sims <- list()
for(i in 1:(length(dist_sim))){
  ibd_sims[[i]] <- mantel.randtest(Dgeo, dist_sim[[i]])
}

plot(Dgeo, dist_sim[[1]])
points(jitter(Dgeo),dist_sim[[2]], col="red", cex=0.5)
points(jitter(Dgeo),dist_sim[[3]], col="blue", cex=0.5)
points(jitter(Dgeo),dist_sim[[4]], col="green", cex=0.5)

```



#Isolation by distance   
```{r}
## without TC Phacelia gina-glennea
Dgenind.noTC <- dist(ph1@tab) #euclidean
Dgenind.maximum.noTC <- dist(ph1@tab, method="max")
Dgeo.noTC <- dist(ph1$other$xy)
#These are the genetic and geographic distance for 425 individuals
ibd.noTC <- mantel.randtest(Dgenind.noTC,Dgeo.noTC) #OH dear, Dgen is 15 populations, Dgeo are all individuals
ibd.noTC

plot(ibd.noTC)


vegan::mantel(Dgeo.noTC,Dgenind.noTC)

ibdmax <- mantel.randtest(Dgeo,Dgenind.maximum)
ibdmax

#vegan version
vegan::mantel(Dgeo,Dgenind, permutations = 9999)
# 1. Classical IBD would result in continuous clines of genetic differentiation 
# 2. distant and differentiated populations also results in this pattern. So...

#Plot- can see patches
dens.tc <- kde2d(Dgeo.noTC,Dgenind.noTC, n=300)
myPal <- colorRampPalette(c("white","blue","gold", "orange", "red"))
plot(Dgeo.noTC, Dgenind.noTC, pch=20,cex=.5)
image(dens.tc, col=transp(myPal(300),.7), add=TRUE)
abline(lm(Dgenind.noTC~Dgeo.noTC))
title("Isolation by distance plot")

#Convert the Northing/Easting to lat/long
ptsutm <- SpatialPoints(phfo.gen[,c("Easting","Northing")],
                        proj4string = CRS("+proj=utm +zone=13 +datum=NAD83"))
ptsgeo <- spTransform(ptsutm, CRS("+proj=longlat +datum=WGS84"))

latlonphfo <- data.frame(phfo.gen,ptsgeo)
```

#Mantel test    
##2018.01.12_updates  
        - want to make PCA of soils and climate for distance matric of environment, compare to distance matrix of genetic    
ape
ade4

Isolation by distance (IBD) and Isolation by environment (IBE)
1) Mantel test
vegan - Forester et al 2016    
spatial eigenfunction analysis and multivariate linear regression (Diniz-Filho et al. 2013 and Legendre et al. 2015)  
i - PCoA to pairwise multivariate genetic distance matrix (Bray-Curtis)
ii - keep PCoA axes based on the broken-stick criterion (Legendre & Legendre 2012)   
iii - response data = kept axes, for redundancy analysis - mutivariate linear regression (RDA)
iv - predictors are spatial eigenfunctions (distance-based Moran's eigenvector maps, dbMEMs)
v - forward selection to reduce number of dbMEMs (Blanchet et al. 2008)
vi - calcuate r^2 assess signficantion using 1000 permutations   
<https://github.com/rforge/sedar/tree/master/pkg> 
both PCNM and packfor    
<http://dr-k-lo.blogspot.com/2012/04/how-to-do-mantel-test-in-r.html>     

<http://popgen.nescent.org/2015-05-18-Dist-SNP.html#section-2.-individual-genetic-distance-euclidean-distance-dist-adegenet> 



soils <https://www.nrcs.usda.gov/wps/portal/nrcs/detail/soils/survey/?cid=nrcs142p2_053627>
Data from USDA <http://websoilsurvey.nrcs.usda.gov/app/WebSoilSurvey.aspx>   
 1. Analsis Tools -> Overlay -> Spatial Join 2. In spatial join dialog box: -Target features = Points -Join features = Polygons -Join Operation = Join one to one -Right click on 'yield' field in join feature field map, select properties, choose 'Maximum' as merge rule -Match option = Intersect 
Try to get netCDF data for these points

Diniz-Filho et al 2013   
```{r, eval=FALSE}
options(prism.path = "Q:/Research/All_Projects_by_Species/Astragalus SPECIES/Astragalus_microcymbus/PRISM_asmiclimate")

#Precipitation total, rain and snow
get_prism_monthlys(type="ppt", mon = 1:12, keepZip = FALSE, years = 1980:1993)

#Maximum temperature (average)
get_prism_monthlys(type="tmax", mon = 1:12, keepZip = FALSE, years = 1980:1993)

#Minimum temperature (average)
get_prism_monthlys(type="tmin", mon = 1:12, keepZip = FALSE, years = 1980:1993)

```


```{r, eval=FALSE}
options(prism.path = "Q:/Research/All_Projects_by_Species/Astragalus SPECIES/Astragalus_microcymbus/PRISM_asmiclimate")

maxs <- grep("tmax", ls_prism_data(absPath=TRUE)[,2])
mins <- grep("tmin", ls_prism_data(absPath = TRUE)[,2])
ppt <- grep("ppt", ls_prism_data(absPath = TRUE)[,2])

avgTemps.max <- lapply(maxs, function(x){
  rastertemps <- raster(ls_prism_data(absPath=TRUE)[x,2])
  data.frame(data = extract(rastertemps, phfo.UTM[,c("lon","lat")]),              
             date = ls_prism_data()[x,])
})

avgTemps.min <- lapply(mins, function(x){
  rastertemps <- raster(ls_prism_data(absPath=TRUE)[x,2])
    data.frame(data = extract(rastertemps, phfo.UTM[,c("lon","lat")]), 
             date = ls_prism_data()[x,])
})

avgPrecip <- lapply(ppt, function(x){
  rastertemps <- raster(ls_prism_data(absPath=TRUE)[x,2])  
  data.frame(data = extract(rastertemps, phfo.UTM[,c("lon","lat")]), 
             date = ls_prism_data()[x,])
})
# These are the points, not the averages yet
mins.avg <- do.call(rbind, avgTemps.min)
maxs.avg <- do.call(rbind, avgTemps.max)
ppt.avg <- do.call(rbind, avgPrecip)

# also want the variance. so the SE of the averages

save(mins.avg, file="P:/hackathon/Phacelia/mins_avg.rda")
save(maxs.avg, file="P:/hackathon/Phacelia/maxs_avg.rda")
save(ppt.avg, file="P:/hackathon/Phacelia/ppt_avg.rda")


```


```{r}
load("P:/hackathon/Phacelia/mins_avg.rda")
load("P:/hackathon/Phacelia/maxs_avg.rda")
load("P:/hackathon/Phacelia/ppt_avg.rda")

```

<https://cran.r-project.org/web/packages/dismo/vignettes/sdm.pdf>   
The code above returns a raster with the 18 bioclimate variables covering the whole world with a resoltion of 2.5 minutes of degrees:
averaged over 1960-1990

    BIO1 = Annual Mean Temperature  
    BIO2 = Mean Diurnal Range (Mean of monthly (max temp - min temp))  
    BIO3 = Isothermality (BIO2/BIO7) (* 100)  
    BIO4 = Temperature Seasonality (standard deviation *100)  
    BIO5 = Max Temperature of Warmest Month  
    BIO6 = Min Temperature of Coldest Month  
    BIO7 = Temperature Annual Range (BIO5-BIO6)   
    BIO8 = Mean Temperature of Wettest Quarter  
    BIO9 = Mean Temperature of Driest Quarter  
    BIO10 = Mean Temperature of Warmest Quarter  
    BIO11 = Mean Temperature of Coldest Quarter  
    BIO12 = Annual Precipitation  
    BIO13 = Precipitation of Wettest Month  
    BIO14 = Precipitation of Driest Month  
    BIO15 = Precipitation Seasonality (Coefficient of Variation)  
    BIO16 = Precipitation of Wettest Quarter  
    BIO17 = Precipitation of Driest Quarter  
    BIO18 = Precipitation of Warmest Quarter  
    BIO19 = Precipitation of Coldest Quarter  

Bioclim data for Jackson, Larimer, and Grand counties
```{r}
bioclim.phfo <- getData("worldclim", var='bio', res = 0.5, lon = -106, lat = 41)

usa <- getData("GADM", country="USA", level=2)
colorado <- usa[usa$NAME_1 == "Colorado",]
counties <- c("Larimer","Jackson","Grand")
ph.counties <- colorado[colorado$NAME_2 %in% grep(paste(counties, collapse="|"),
                                                 colorado$NAME_2, value=TRUE),]
ph.counties <- ph.counties[ph.counties$NAME_2 != "Rio Grande",]
 
plot(bioclim.phfo[[1]], xlim=c(-106.5,-105),ylim=c(40,41.125))
points(phfo.UTM[,c("lon","lat")], col=phfo.UTM$Code)
plot(ph.counties, add=TRUE)

```

#Background points
To create background points:  
```{r, eval=FALSE}
# Save the circles and the convex hull as shapefile, break into 100^2 km chunkcs, feed into the soils usda site and get that coverage for phfo
xSPDF <- as(x@polygons, "SpatialPolygonsDataFrame")
writeOGR(xSPDF, layer="xCircles", dsn = "Q:/Research/All_Projects_by_Species/Phacelia SPECIES/Phacelia_formosula/Phacelia formosula_abiotic/Maps", driver="ESRI Shapefile")

convHSPDF <- as(convH@polygons, "SpatialPolygonsDataFrame")
writeOGR(convHSPDF, layer="xConvHull", dsn = "Q:/Research/All_Projects_by_Species/Phacelia SPECIES/Phacelia_formosula/Phacelia formosula_abiotic/Maps", driver="ESRI Shapefile")

disx <- disaggregate(x@polygons)
class(disx)
str(disx)

#cs <- c(3.65,3.65)*6000 #grid must be 100,000 acres: 1 acre = 4046.86 square meter; 1 degree latitude = 111.03 km | 68.99 miles and longitude = 1.42 km | 0.88 miles
#405km
405/111.03 #3.65


#cd <- ceiling(diff(t(bb))/cs) # number of cells per direction
#grd <- GridTopology(cellcentre.offset = bb[,1]+cs/2, cellsize = cs, cells.dim=cd)
#sp_grd <- SpatialGridDataFrame(grd,
#                               data=data.frame(id=1:prod(cd)),
#                               proj4string=CRS(proj4string(x@polygons)))
#plot(sp_grd)
```


Create a raster of approximately 100,000 acres for the soils usda website to download portions to cover the entire area of the three county speices. 
```{r, eval=FALSE}
r <- raster()
bb <- bbox(x@polygons) #Spatial bounding box, sp::bbox

res(r) <- 3.65*15
r <- setExtent(r, bb)
r <- setValues(r,seq(1,r@ncols*r@nrows))
plot(r)
plot(ph.counties, add=TRUE)
points(phfo.UTM[,c("lon","lat")], col="red") 
points(bgd, col=rgb(0,0.5,1,0.5))

```

raster to shapefile  
Still all the extent of the whole raster, not just the extent of each
```{r, eval=FALSE}

for(i in 1:(r@ncols*r@nrows)){
  r1 <- r==i
#  r1[r1!=i] <- NA
  r1 <- trim(r1, values=FALSE)
  p <- as(extent(r1), "SpatialPolygons")
  crs(p) <- proj4string(r)
  pSPDF <- as(p, "SpatialPolygonsDataFrame")
  writeOGR(pSPDF, layer=paste0("phfogrid",i),
            dsn = "Q:/Research/All_Projects_by_Species/Phacelia SPECIES/Phacelia_formosula/Phacelia formosula_abiotic/Maps", driver="ESRI Shapefile")

#  writeRaster(r1, paste("Q:/Research/All_Projects_by_Species/Phacelia SPECIES/Phacelia_formosula/Phacelia formosula_abiotic/Maps/phforas",i,".tif",sep=""))
}
```

```{r, eval=FALSE}
plot(ph.counties)
plot(x, col=rgb(1,0.5,1,0.5), add=TRUE)
plot(convH, add=TRUE, col=rgb(0,0.5,1,0.5))
points(phfo.UTM[,c("lon","lat")], col="blue") 
points(bgd)
```





#Soils   
 
Steps to get soil layers <"Q:\Research\All_Projects_by_Species\Phacelia SPECIES\Phacelia_formosula\Phacelia formosula_abiotic\Modelling\Soil_layer_data_extraction\Notes_on_soil_data_file_making.docx">   
```{r, echo=FALSE}
filenames <- list.files("Q:/Research/All_Projects_by_Species/aa_Shapefiles_Maps/Phacelia formosula/SoilLayers")
flnms <- unique(sapply(strsplit(filenames,"[.]"),'[',1)) #13 layers I have

# AWS025
# depthWT
# ph030
# stext

shape <- list()
#Get all the soil layers I made, Jessie made most of them!
for(i in flnms){
  shape[[i]] <- readOGR("Q:/Research/All_Projects_by_Species/aa_Shapefiles_Maps/Phacelia formosula/SoilLayers", layer = paste(i))
}

#Dissolve polygons by type
types <- c("AWS","depthWT","ph030","stext")

typeall <- lapply(types, function(tp){
  do.call(rbind,lapply(which(flnms %in% flnms[grep(tp,flnms)]),
                       function(x){
                         shape[[x]]
                         }))
  })

save(typeall, file="P:/hackathon/Phacelia/typeall_soils.rda")

```


<https://cran.r-project.org/web/packages/dismo/vignettes/sdm.pdf>  
Overlap methods for background and presence points  Ward et al. 2009; Phillips and Elith, 2011  

```{r}
phfo.spdf <- SpatialPointsDataFrame(phfo.UTM[,c("lon","lat")],
                                    phfo.UTM)

# create background points for convex hull for all three
convH <- convHull(phfo.spdf)

# create background #2 with smaller circles around each county populations only   
# Need a grid to get one point per grid of size whatever bioclim is to get background points? 
x <- circles(phfo.UTM[,c("lon","lat")], d=10000, lonlat=TRUE) #10 km

#same grid as bioclim
#Make spatialpointsdataframe
#background.mask <- mask(bioclim.phfo[[1]], polygons(x),filename="Q:/Research/All_Projects_by_Species/Phacelia SPECIES/Phacelia_formosula/Phacelia formosula_abiotic/Maps/bc_mk_phfo_1",overwrite=TRUE)
#save(background.mask,
#     file="P:/hackathon/Phacelia/background.rda")
load("P:/hackathon/Phacelia/background.rda")


bgd <- randomPoints(background.mask, 500)

plot(ph.counties)
plot(x, col=rgb(1,0.5,1,0.5), add=TRUE)
#plot(convH, add=TRUE, col=rgb(0,0.5,1,0.5))
points(phfo.UTM[,c("lon","lat")], col="blue", pch=16) 
#plot(background.mask, add=TRUE)
```


Now extract points from all the bioclim layers, plot them in a pretty layout
```{r}

#extract background and county points
# add background points to other list
bgdtoadd <- data.frame(t(matrix(NA,length(names(phfo.spdf)),
                                nrow(bgd),byrow = TRUE)))
names(bgdtoadd) <- names(phfo.spdf)
bgdtoadd[,c("lon","lat")] <- bgd
bgdtoadd$Code <- "background"

#take over FID to group by county for plotting, 1:Jackson,2:Larimer,3:Grand
phfo.spdf$FID <- 1
phfo.spdf$FID[phfo.spdf$Code %in% c("HN","HS","FC")] <- 2
phfo.spdf$FID[phfo.spdf$Code %in% c("TC")] <- 3
bgdtoadd$FID <- 4

phfo.spdf <- rbind(phfo.spdf@data,bgdtoadd)

#bio is a list of bioclim values at each point

#extract rasters to data
bio<-list()
for(i in 1:19){
  bio[[i]] <- extract(bioclim.phfo[[i]], phfo.spdf[,c("lon","lat")]) # projected from UTM Z13 NAD83 to longlat WGS84
}

#one matrix with bioclims and soils for presence points
abiotic.phfo <- do.call(cbind,bio) #matrix of 425 presence points and 500 background points by 19 bioclim variables

save(abiotic.phfo, file="P:/hackathon/Phacelia/abiotic_phfo.rda")

```


```{r}
#load("P:/hackathon/Phacelia/abiotic_phfo.rda")
load("P:/hackathon/Phacelia/typeall_soils.rda")

load("P:/hackathon/Phacelia/abiotic_phfo.rda")
prabpoints <- SpatialPoints(phfo.spdf[,c("lon","lat")],
                                     #data=phfo.spdf,
                proj4string=CRS(proj4string(typeall[[1]])))

#Extract soil layers to points data
soil<-list()
for(i in 1:length(typeall)){
  soil[[i]] <- over(prabpoints,typeall[[i]])
}

#one matrix with bioclims and soils for presence points
pr.soil <- do.call(cbind,soil)
typescol <- c("AWS","Dep2","pH","Surf")
pr.soil.all <- (pr.soil[,grep(paste(typescol,
                         collapse="|"),names(pr.soil),
                   value=TRUE)])

abiotic.phfo <- data.frame(abiotic.phfo)
names(abiotic.phfo) <- paste("bio",1:19,sep="")

#phfo.spdf: 425 20
#abiotic.phfo: 925 19 (the bioclim variables for 425 points and 500 background)
#pr.soil.all: 425 4 ()
phfo.bioclim.soils <-
  data.frame(phfo.spdf,abiotic.phfo,pr.soil.all) 

#If haven't run the above percent missing data chunk
op <- par(no.readonly = TRUE)

# canberra meant for non-negative counts, out, but it does measure relative distance
# binary only for binary data, out
# Euclidean isn't great in high dimensions - squares the differences
# Manhattan just takes absolute value


```

```{r}
library(corrplot)

names(phfo.bioclim.soils)

cor_matrix <- cor(phfo.bioclim.soils[,c(21:39)])
corrplot(cor_matrix, method="square", type="upper")

```

Bio12:19 are all highly correlated (>0.5) so for simplicity, just keep Bio12, annual precipitation  

Bio8 and 12 are still correlated, (mean temp of wettest quarter) so 8 is out  
Bio11 is problematic (correlated to 1,2,4,5, and 7)  Out  

Bio7 probably better than 4, 5 or 6

bio2 out  

```{r}

cor_matrix <- cor(phfo.bioclim.soils[,c("bio1","bio7","bio9","bio12")])
corrplot(cor_matrix, method="square", type="upper")

forPCA <- phfo.bioclim.soils[,c("bio1","bio7","bio9","bio12")]
```

2018-09-07 try getting rid if correlated over 75%


```{r}

cor(phfo.bioclim.soils[,c(22:40)])
# 1 vs 5 and 1 vs. 10, keep 1, 5 and 10 out
names(phfo.bioclim.soils[,c(22:25,27:30,32:40)])
cor(phfo.bioclim.soils[,c(22:25,27:30,32:40)])

# 2 vs 4, 2 vs 7, 2 vs 7; sure keep 2
names(phfo.bioclim.soils[,c(22:24,27,29:30,32:40)])
cor(phfo.bioclim.soils[,c(22:24,27,29:30,32:40)])

# 3 vs 12, 14, 15, 17, 19: keep 12, 12 vs. 3, 8,13:19
names(phfo.bioclim.soils[,c(22:23,27,29:30,32:33)])
cor(phfo.bioclim.soils[,c(22:23,27,29:30,32:33)])


# 2 vs 6; keep 6; 8 vs 12, keep 12, keep 11, not 6
names(phfo.bioclim.soils[,c(22,30,32:33)])
cor(phfo.bioclim.soils[,c(22,30,32:33)])

cor_matrix <- cor(phfo.bioclim.soils[,c("bio1",  "bio9",  "bio11", "bio12")])
corrplot(cor_matrix, method="square", type="upper")

```


Principal components Analysis
```{r}
phfopca <- princomp(forPCA, cor=TRUE) #use the correlation matrix, not covariance

sumforplot <- summary(phfopca)
sumforplot$center
sumforplot$scale
PoV <- phfopca$sdev^2/sum(phfopca$sdev^2) #The proportion of the variance (standard deviation^2) for each componant to the total variance 
phfo.load <- loadings(phfopca)
phfo.pc <- predict(phfopca)

pcaphfo.bioclim.soils <- data.frame(phfo.pc,phfo.bioclim.soils)

#Not quite, just want the background points
meanComp1 <- aggregate(Comp.1~FID, data=pcaphfo.bioclim.soils, mean)
meanComp2 <- aggregate(Comp.2~FID, data=pcaphfo.bioclim.soils, mean)

# I'd want to show 2 standard deviations to show the breadth of possible environemtns in which these populations fall
SDComp1 <- aggregate(Comp.1~FID, data=pcaphfo.bioclim.soils, sd)
SDComp2 <- aggregate(Comp.2~FID, data=pcaphfo.bioclim.soils, sd)

#Confidence interval around the mean, not really want I want to show
CIComp1 <- aggregate(Comp.1~FID, data=pcaphfo.bioclim.soils,
                     function(x) qnorm(1-0.05/2)*(sd(x)/sqrt(length(x))))
CIComp2 <- aggregate(Comp.2~FID, data=pcaphfo.bioclim.soils,
                     function(x) qnorm(1-0.05/2)*(sd(x)/sqrt(length(x))))

```

```{r}
jpeg(paste("C:/Users/deprengm/Dropbox/Denver Botanic Gardens Postdoctoral Genetic Files/Phacelia project/PCA_Bio1_7_9_12.jpg"), width=150, height=150, units="mm", res=300)

layout(matrix(c(2,4,1,3),2,2, byrow=TRUE), widths=c(3,1), heights=c(1,3), TRUE)
par(mai=c(1,1,.1,.1)) #margins for plot 1

plot(pcaphfo.bioclim.soils$Comp.1[pcaphfo.bioclim.soils$FID==4],
     pcaphfo.bioclim.soils$Comp.2[pcaphfo.bioclim.soils$FID==4], 
     col=rgb(0,0,0,0.05),pch=16,
     xlab=paste("Comp.1 (Proportion of Variance ",round(PoV[1],2)*100,"%)",
                sep=""), 
     ylab=paste("Comp.2 (Proportion of Variance ", round(PoV[2],2)*100,
                "%)", sep=""))
points(meanComp1[4,2],meanComp2[4,2], pch=16)
arrows(meanComp1[4,2],meanComp2[4,2],
      meanComp1[4,2]+2*SDComp1[4,2],meanComp2[4,2],
      length=0.1,angle=90)
arrows(meanComp1[4,2],meanComp2[4,2],
      meanComp1[4,2]-2*SDComp1[4,2],meanComp2[4,2],
      length=0.1,angle=90)
arrows(meanComp1[4,2],meanComp2[4,2],
      meanComp1[4,2],meanComp2[4,2]+2*SDComp2[4,2],
      length=0.1,angle=90)
arrows(meanComp1[4,2],meanComp2[4,2],
      meanComp1[4,2],meanComp2[4,2]-2*SDComp2[4,2],
      length=0.1,angle=90)
points(pcaphfo.bioclim.soils$Comp.1[pcaphfo.bioclim.soils$FID==1],
     pcaphfo.bioclim.soils$Comp.2[pcaphfo.bioclim.soils$FID==1], 
     pch = 1)
points(pcaphfo.bioclim.soils$Comp.1[pcaphfo.bioclim.soils$FID==2],
     pcaphfo.bioclim.soils$Comp.2[pcaphfo.bioclim.soils$FID==2], 
     pch=2)
points(pcaphfo.bioclim.soils$Comp.1[pcaphfo.bioclim.soils$FID==3],
     pcaphfo.bioclim.soils$Comp.2[pcaphfo.bioclim.soils$FID==3],
     pch=3)
legend("topright",
       pch=c(1,2,3),
       legend = c("Jackson","Larimer","Grand")) 

#plot 2 Comp.1
par(mai=c(.1,1,.1,.1)) 
plot(density(pcaphfo.bioclim.soils$Comp.1[pcaphfo.bioclim.soils$FID==4]),
     xaxt='n',
     main="",
     col=rgb(0,0,0,0.15),
     ylim=c(0,3))
lines(density(pcaphfo.bioclim.soils$Comp.1[pcaphfo.bioclim.soils$FID==1]),
      lty=1)
lines(density(pcaphfo.bioclim.soils$Comp.1[pcaphfo.bioclim.soils$FID==2]),
      lty=2)
lines(density(pcaphfo.bioclim.soils$Comp.1[pcaphfo.bioclim.soils$FID==3]),
      lty=3)

yhist4 <- hist(pcaphfo.bioclim.soils$Comp.2[pcaphfo.bioclim.soils$FID==4], plot=FALSE)
yhist1 <- hist(pcaphfo.bioclim.soils$Comp.2[pcaphfo.bioclim.soils$FID==1], plot=FALSE)
yhist2 <- hist(pcaphfo.bioclim.soils$Comp.2[pcaphfo.bioclim.soils$FID==2], plot=FALSE)
yhist3 <- hist(pcaphfo.bioclim.soils$Comp.2[pcaphfo.bioclim.soils$FID==3], plot=FALSE)


#trail plot 3


#plot 3 Comp.2
par(mai=c(1,.1,.1,.1)) 
plot(yhist4$density, seq(from=min(yhist4$breaks),
                         to=max(yhist4$breaks),
                         length.out = length(yhist4$density)),
     yaxt='n',
     main="",
     type="l",
     col=rgb(0,0,0,0.15),
     xlim=c(0,7.5), xlab="Density")
lines(yhist1$density, seq(from=min(yhist1$breaks),
                         to=max(yhist1$breaks),
                         length.out = length(yhist1$density)),
     lty=1, main="",xaxt='n')
lines(yhist2$density, seq(from=min(yhist2$breaks),
                         to=max(yhist2$breaks),
                         length.out = length(yhist2$density)),
      lty=2)
lines(yhist3$density, seq(from=min(yhist3$breaks),
                         to=max(yhist3$breaks),
                         length.out = length(yhist3$density)),
      lty=3)

#Line legend
par(mai=c(.1,.1,.1,.1))
plot(1:6,1:6, type='n', axes=FALSE, main="")
legend("topright", legend =c("Jackson","Larimer","Grand","Background"),
       lty=c(1:3,1),
       col=c(rep("black",3),"grey"),
       bty='n')

dev.off()
```

```{r}
marginal_plot = function(x, y, group = NULL, data = NULL, lm_show = FALSE, lm_formula = y ~ x, bw = "nrd0", adjust = 1, alpha = 1, plot_legend = T, ...){
  require(scales)
  ###############
  # Plots a scatterplot with marginal probability density functions for x and y. 
  # Data may be grouped or ungrouped. 
  # For each group, a linear fit can be plotted. It is hidden by default, but can be shown by providing lm_show = TRUE.
  # The model can be modified using the 'lm_formula' argument.
  # The 'bw' and 'adjust' argument specify the granularity used for estimating probability density functions. See ?density for more information.
  # For large datasets, opacity may be decreased by setting alpha to a value between 0 and 1.
  # Additional graphical parameters are passed to the main plot, so you can customize axis labels, titles etc.
  ###############
  moreargs = eval(substitute(list(...)))
  
  # prepare consistent df
  if(missing(group)){
    if(missing(data)){
      if(length(x) != length(y)){stop("Length of arguments not equal")}
      data = data.frame(x = as.numeric(x), y = as.numeric(y))
    } else {
      data = data.frame(x = as.numeric(data[,deparse(substitute(x))]), 
                        y = as.numeric(data[,deparse(substitute(y))]))
    }
    if(sum(!complete.cases(data)) > 0){
      warning(sprintf("Removed %i rows with missing data", sum(!complete.cases(data))))
      data = data[complete.cases(data),]
    }
    group_colors = "black"
  } else {
    if(missing(data)){
      if(length(x) != length(y) | length(x) != length(group)){stop("Length of arguments not equal")}
      data = data.frame(x = as.numeric(x), y = as.numeric(y), group = as.factor(group))
    } else {
      data = data.frame(x = as.numeric(data[,deparse(substitute(x))]), 
                        y = as.numeric(data[,deparse(substitute(y))]),
                        group = as.factor(data[,deparse(substitute(group))]))
    }
    if(sum(!complete.cases(data)) > 0){
      warning(sprintf("Removed %i rows with missing data", sum(!complete.cases(data))))
      data = data[complete.cases(data),]
    }
    data = subset(data, group %in% names(which(table(data$group) > 5)))
    data$group = droplevels(data$group)
    group_colors = rainbow(length(unique(data$group)))
  } 
  
  # log-transform data (this is need for correct plotting of density functions)
  if(!is.null(moreargs$log)){
    if(!moreargs$log %in% c("y", "x", "yx", "xy")){
      warning("Ignoring invalid 'log' argument. Use 'y', 'x', 'yx' or 'xy.")
    } else {
      data = data[apply(data[unlist(strsplit(moreargs$log, ""))], 1, function(x) !any(x <= 0)), ]
      data[,unlist(strsplit(moreargs$log, ""))] = log10(data[,unlist(strsplit(moreargs$log, ""))])
    }
    moreargs$log = NULL # remove to prevent double logarithm when plotting
  }
  
  # Catch unwanted user inputs
  if(!is.null(moreargs$col)){moreargs$col = NULL}
  if(!is.null(moreargs$type)){moreargs$type = "p"}
  
  # get some default plotting arguments
  if(is.null(moreargs$xlim)){moreargs$xlim = range(data$x)} 
  if(is.null(moreargs$ylim)){moreargs$ylim = range(data$y)}
  if(is.null(moreargs$xlab)){moreargs$xlab = deparse(substitute(x))}
  if(is.null(moreargs$ylab)){moreargs$ylab = deparse(substitute(y))}
  if(is.null(moreargs$las)){moreargs$las = 1} 
  
  # plotting
  tryCatch(expr = {
    ifelse(!is.null(data$group), data_split <- split(data, data$group), data_split <- list(data))
    orig_par = par(no.readonly = T)
    par(mar = c(0.25,5,1,0))
    layout(matrix(1:4, nrow = 2, byrow = T), widths = c(10,3), heights = c(3,10))
    
    # upper density plot
    plot(NULL, type = "n", xlim = moreargs$xlim, ylab = "density",
         ylim = c(0, max(sapply(data_split, function(group_set) max(density(group_set$x, bw = bw)$y)))), main = NA, axes = F)
    axis(2, las = 1)
    mapply(function(group_set, group_color){lines(density(group_set$x, bw = bw, adjust = adjust), col = group_color, lwd = 2)}, data_split, group_colors)
    
    # legend
    par(mar = c(0.25,0.25,0,0))
    plot.new()
    if(!missing(group) & plot_legend){
      legend("center", levels(data$group), fill = group_colors, border = group_colors, bty = "n", title = deparse(substitute(group)), title.adj = 0.1)
    }
    
    # main plot
    par(mar = c(4,5,0,0))
    if(missing(group)){
      do.call(plot, c(list(x = quote(data$x), y = quote(data$y), col = quote(scales::alpha("black", alpha))), moreargs))
    } else {
      do.call(plot, c(list(x = quote(data$x), y = quote(data$y), col = quote(scales::alpha(group_colors[data$group], alpha))), moreargs))
    }
    axis(3, labels = F, tck = 0.01)
    axis(4, labels = F, tck = 0.01)
    box()
    
    if(lm_show == TRUE & !is.null(lm_formula)){
      mapply(function(group_set, group_color){
        lm_tmp = lm(lm_formula, data = group_set)
        x_coords = seq(min(group_set$x), max(group_set$x), length.out = 100)
        y_coords = predict(lm_tmp, newdata = data.frame(x = x_coords))
        lines(x = x_coords, y = y_coords, col = group_color, lwd = 2.5)
      }, data_split, rgb(t(ceiling(col2rgb(group_colors)*0.8)), maxColorValue = 255))
    }
    
    # right density plot
    par(mar = c(4,0.25,0,1))
    plot(NULL, type = "n", ylim = moreargs$ylim, xlim = c(0, max(sapply(data_split, function(group_set) max(density(group_set$y, bw = bw)$y)))), main = NA, axes = F, xlab = "density")
    mapply(function(group_set, group_color){lines(x = density(group_set$y, bw = bw, adjust = adjust)$y, y = density(group_set$y, bw = bw)$x, col = group_color, lwd = 2)}, data_split, group_colors)
    axis(1)
  }, finally = {
    par(orig_par)
  })
}
```


```{r}
jpeg("C:/Users/deprengm/Dropbox/Denver Botanic Gardens Postdoctoral Genetic Files/Phacelia project/Manuscript/Figures/SurfaceText_DepthtoWaterTable.jpg",
     width=150, height=125,units='mm', res=300)
     
marginal_plot(x=SurfText, y=Dep2WatTbl, data=pcaphfo.bioclim.soils[pcaphfo.bioclim.soils$FID!=4,],
              group=FID,
              xlab="Surface Texture",
              ylab="Depth to water table")

dev.off()

write.table(table(pcaphfo.bioclim.soils$SurfText, pcaphfo.bioclim.soils$Code),
            "clipboard", sep="\t", row.names=TRUE)
```

```{r}
jpeg("C:/Users/deprengm/Dropbox/Denver Botanic Gardens Postdoctoral Genetic Files/Phacelia project/Manuscript/Figures/AvailableSurfaceWater0_25cm__pH.jpg",
     width=150, height=125,units='mm', res=300)

marginal_plot(x=AWS025, y=pHwater, data=pcaphfo.bioclim.soils[pcaphfo.bioclim.soils$FID!=4,],
              group=FID,
              xlab="Avaliable surface water",
              ylab="pH")

dev.off()
```

```{r}


marginal_plot(x=Comp.1, y=Comp.2, data=pcaphfo.bioclim.soils[pcaphfo.bioclim.soils$FID<3,],
              group=FID,
              xlab="Comp 1",
              ylab="Comp 2")
```

```{r}
cor_soil <- cor(phfo.bioclim.soils[,c(40:42)], use = "pairwise.complete.obs")
corrplot(cor_soil)

meanDepth <- aggregate(AWS025~FID, data=pcaphfo.bioclim.soils, mean)
meanph <- aggregate(pHwater~FID, data=pcaphfo.bioclim.soils, mean)
SDDepth <- aggregate(AWS025~FID, data=pcaphfo.bioclim.soils, sd)
SDph <- aggregate(pHwater~FID, data=pcaphfo.bioclim.soils, sd)

CIDepth <- aggregate(AWS025~FID, data=pcaphfo.bioclim.soils,
                     function(x) qnorm(1-0.05/2)*(sd(x)/sqrt(length(x))))
CIph <- aggregate(pHwater~FID, data=pcaphfo.bioclim.soils,
                  function(x) qnorm(1-0.05/2)*(sd(x)/sqrt(length(x))))
```

```{r}
plot(pcaphfo.bioclim.soils$AWS025[pcaphfo.bioclim.soils$FID<4],
     pcaphfo.bioclim.soils$pHwater[pcaphfo.bioclim.soils$FID<4], type="n",
     xlab="Avaliable surface water", ylab="pH")
points(meanDepth[-4,2],meanph[-4,2], pch=21, cex=2, col=c("red","blue","goldenrod"))
# for(i in 1:3){
#  arrows(meanDepth[i,2],meanph[i,2],
#       meanDepth[i,2]+CIDepth[i,2],meanph[i,2],
#       length=0.1,angle=90)
#  arrows(meanDepth[i,2],meanph[i,2],
#        meanDepth[i,2]-CIDepth[i,2],meanph[i,2],
#        length=0.1,angle=90)
#  arrows(meanDepth[i,2],meanph[i,2],
#        meanDepth[i,2],meanph[i,2]+CIph[i,2],
#        length=0.1,angle=90)
#  arrows(meanDepth[i,2],meanph[i,2],
#        meanDepth[i,2],meanph[i,2]-CIph[i,2],
#        length=0.1,angle=90)
# }
points(pcaphfo.bioclim.soils$AWS025[pcaphfo.bioclim.soils$FID==1],
     pcaphfo.bioclim.soils$pHwater[pcaphfo.bioclim.soils$FID==1], 
     pch = 16, col="red")
points(pcaphfo.bioclim.soils$AWS025[pcaphfo.bioclim.soils$FID==2],
     pcaphfo.bioclim.soils$pHwater[pcaphfo.bioclim.soils$FID==2], col="blue",      pch=17)
points(pcaphfo.bioclim.soils$AWS025[pcaphfo.bioclim.soils$FID==3],
     pcaphfo.bioclim.soils$pHwater[pcaphfo.bioclim.soils$FID==3],     col="goldenrod", pch=18)
legend("bottomleft",
       pch=c(16,17,18),
       col=c("red","blue","goldenrod"),
       legend = c("Jackson","Larimer","Grand")) 


```

```{r}
scatterplotMatrix(~bio1+bio2+bio3+bio4, 
                 diagonal = "qqplot",
                 groups = phfo.bioclim.soils$FID,
                 data=phfo.bioclim.soils,
                 reg.line=FALSE,
                 smoother="")

# most normally distributed: bio2, get rid of bio1, bio4, and bio3

scatterplotMatrix(~bio1+bio2+bio3+bio4, 
                 diagonal = "density",
                 groups = phfo.bioclim.soils$FID,
                 data=phfo.bioclim.soils,
                 reg.line=FALSE,
                 smoother="")
```

```{r}
scatterplotMatrix(~bio5+bio2+bio6+bio7, 
                 diagonal = "density",
                 groups = phfo.bioclim.soils$FID,
                 data=phfo.bioclim.soils,
                 reg.line=FALSE,
                 smoother="")

#Only keep 2: Mean Diurnal Range (Mean of monthly (max temp - min temp))
```
```{r}
scatterplotMatrix(~bio8+bio2+bio9+bio10, 
                 diagonal = "density",
                 groups = phfo.bioclim.soils$FID,
                 data=phfo.bioclim.soils,
                 reg.line=FALSE,
                 smoother="")

#keep 2: Mean Diurnal Range (Mean of monthly (max temp - min temp))
#keep 9: Mean Temperature of Driest Quarter
```
```{r}
scatterplotMatrix(~bio11+bio2+bio9+bio12, 
                 diagonal = "density",
                 groups = phfo.bioclim.soils$FID,
                 data=phfo.bioclim.soils,
                 reg.line=FALSE,
                 smoother="")

#keep 2: Mean Diurnal Range (Mean of monthly (max temp - min temp))
#keep 9: Mean Temperature of Driest Quarter
#keep 12: Annual Precipitation
```
```{r}
scatterplotMatrix(~bio15+bio2+bio9+bio12, 
                 diagonal = "density",
                 groups = phfo.bioclim.soils$FID,
                 data=phfo.bioclim.soils,
                 reg.line=FALSE,
                 smoother="")

#keep 2: Mean Diurnal Range (Mean of monthly (max temp - min temp))
#keep 9: Mean Temperature of Driest Quarter
#keep 12: Annual Precipitation
#Keep 15: Precipitation Seasonality (Coefficient of Variation)
# precip bio16:19 all pretty highly correlated. 
```

# PCoA for 
vegan  
  isoMDS - non-metric multidimentsional scaling
  

ade4 - alternative implementation of ordination methods
```{r}


```

metric scaling
```{r}


```



```{r, eval=FALSE}
plotin <- phfo.bioclim.soils[phfo.bioclim.soils$pHwater<100 &
                               phfo.bioclim.soils$AWS025<100,]



scatterplotMatrix(~bio12+AWS025+Dep2WatTbl+pHwater, 
                 diagonal = "density",
                 groups = plotin$FID,
                 data=plotin,
                 reg.line=FALSE,
                 smoother="")


ggplot(plotin[complete.cases(plotin$Code) & plotin$FID<4,], 
       aes(bio12,AWS025, colour=as.factor(FID)))+
  geom_point()+
  geom_point(data=plotin[plotin$FID==4 &
                           complete.cases(plotin$Code),],
                         aes(bio12,AWS025), alpha=0.25)+
  theme_bw()

```
Plot with density of each type, background, three counties on margins
```{r}
xhist_bio12 <- lapply(1:4, function(x){
  histout <- hist(plotin$bio12[complete.cases(plotin$Code) & 
                                 plotin$FID == x],plot=FALSE)
  histout
})

plot(plotin$bio12[complete.cases(plotin$Code) & plotin$FID<4,],
     plotin$AWS025[complete.cases(plotin$Code) & plotin$FID<4,])
```


```{r}
#Turn all three counties in presence = 1 and all background of all three into absent = 0
phfo.bioclim.soils$prab <- 1
phfo.bioclim.soils$prab[phfo.bioclim.soils$FID<4] <- 0
m1 <- glm(prab~bio15+bio2+bio9+bio12, data=phfo.bioclim.soils)
summary(m1)

m2 <- glm(prab~., data=phfo.bioclim.soils[,c(44,21:39)]) #only the bioclim columns

modelpredic <- predict(m1, phfo.bioclim.soils[,c("bio15","bio2","bio9","bio12")])
#From example presvals == phfo.bioclim.soils[phfo.bioclim.soils$FID<4,21:39]
bc <- bioclim(phfo.bioclim.soils[phfo.bioclim.soils$FID<4,
                                 c("bio15","bio2","bio9","bio12")])

response(bc)
```

```{r}
names(bioclim.phfo)
predictors <- stack(bioclim.phfo[[c(2,9,12,15)]])
names(predictors) <- c("bio2","bio9","bio12","bio15")


p<- predict(predictors, m1)
plot(p)
plot(ph.counties, add=TRUE)
```



```{r}

layout.show(layout(matrix(c(7,1,2,3,
                11,8,4,5,
                12,13,9,6,
                14,15,16,10), 4,4,byrow = TRUE)))
```

layoutbioplot <- function(x){ #a vector of climate and/or soil columns from biodata
  rowcols <- length(x)
  uppertri <- sum(seq(rowcols-1,1))
  lowertri <- uppertri+rowcols+1
}
layout(matrix(c(
  uppertri+1,1:rowcols-1,
  uppertri+2,rowcols:rowcols+1,
  uppertri+3,)),
       rowcols,rowcols,byrow=TRUE))

for(i in 4:6){
  par(mai = c(1,1,1,1)/4)
  plot(biodata[,i],biodata[,3],col=biodata$phfo.UTM.Code,
       xaxt="n")
}
for(i in 5:6){
  par(mai = c(1,1,1,1)/4)
  plot(biodata[,i],biodata[,4],col=biodata$phfo.UTM.Code,
       xaxt="n")
}
par(mai = c(1,1,1,1)/4)
plot(biodata[,6],biodata[,5], col=biodata$phfo.UTM.Code,
       xaxt="n")
for(i in 3:6){
  hist(biodata[,i], main="")
  rug(biodata[,i])
}

Meaningless, no differences  
# 2 bio12+Dep2WatTbl, then: pHwater
plot(phfo.bioclim.soils$bio12[phfo.bioclim.soils$FID<4 &
                                phfo.bioclim.soils$Dep2WatTbl>100],
     phfo.bioclim.soils$Dep2WatTbl[phfo.bioclim.soils$FID<4 &
                                     phfo.bioclim.soils$Dep2WatTbl>100],
     col=phfo.bioclim.soils$FID[phfo.bioclim.soils$FID<4&
                                  phfo.bioclim.soils$Dep2WatTbl>100],
     pch=16, axes=FALSE, ylab="", xlab="") 
#"Avaliable Surface Water (0-25cm)",xlab="Annual Precipitation")
axis(side=4,las=1)
points(phfo.bioclim.soils$bio12[phfo.bioclim.soils$FID==4 &
                                  phfo.bioclim.soils$Dep2WatTbl>100],
     phfo.bioclim.soils$Dep2WatTbl[phfo.bioclim.soils$FID==4 &
                                     phfo.bioclim.soils$Dep2WatTbl>100],
     pch=16, cex=2,
     col=rgb(1,0.5,0,0.05))
     
     
```{r}
#plot function with layout
layout(matrix(c(7,1,2,3,
                11,8,4,5,
                12,13,9,6,
                14,15,16,10), 4,4,byrow = TRUE))

# 1 annual precip bio12 to AWS025
phfo.bioclim.soils_sm <- phfo.bioclim.soils[phfo.bioclim.soils$AWS025<100,]
plot(phfo.bioclim.soils_sm$bio12[phfo.bioclim.soils_sm$FID<4],
     phfo.bioclim.soils_sm$AWS025[phfo.bioclim.soils_sm$FID<4],
     col=phfo.bioclim.soils_sm$FID[phfo.bioclim.soils_sm$FID<4],
     pch=16, axes=FALSE, ylab="", xlab="") 
#"Avaliable Surface Water (0-25cm)",xlab="Annual Precipitation")
axis(side=3,las=1)
points(phfo.bioclim.soils_sm$bio12[phfo.bioclim.soils_sm$FID==4],
     phfo.bioclim.soils_sm$AWS025[phfo.bioclim.soils_sm$FID==4],
     pch=16, cex=2,
     col=rgb(1,0.5,0,0.05))

# 2 annual precip to phwater
plot(phfo.bioclim.soils_sm$bio12[phfo.bioclim.soils_sm$FID<4],
     phfo.bioclim.soils_sm$pHwater[phfo.bioclim.soils_sm$FID<4],
     col=phfo.bioclim.soils_sm$FID[phfo.bioclim.soils_sm$FID<4],
     pch=16, axes=FALSE, ylab="", xlab="") 
#"Avaliable Surface Water (0-25cm)",xlab="Annual Precipitation")
axis(side=3,las=1)
points(phfo.bioclim.soils_sm$bio12[phfo.bioclim.soils_sm$FID==4],
     phfo.bioclim.soils_sm$pHwater[phfo.bioclim.soils_sm$FID==4],
     pch=16, cex=2,
     col=rgb(1,0.5,0,0.05))


```

```{r, eval=FALSE}
#Should keep only not correltated ones
cor.table <- cor(biodata[,3:length(biodata)])
data <- as.data.frame(as.table(cor.table))
combns <- combn(colnames(cor.table),2,FUN=function(x) paste(x,collapse = "_"))
cor.data <- data[data$Var1 != data$Var2, ]
data <- cor.data[paste(cor.data$Var1, cor.data$Var2, sep="_") %in% combns,]
head(data)

data[data$Var1 == "bio1.ph" & data$Freq > 0.7,]
data[data$Var2 == "bio1.ph"& data$Freq > 0.7,]
data[data$Freq > 0.7,]

# Keep only annual precipitation
data <- data[data$Var1 != "bio19.ph" & data$Var2 != "bio19.ph",]
data <- data[data$Var1 != "bio18.ph" & data$Var2 != "bio18.ph",]
data <- data[data$Var1 != "bio17.ph" & data$Var2 != "bio17.ph",]
data <- data[data$Var1 != "bio16.ph" & data$Var2 != "bio16.ph",]
data <- data[data$Var1 != "bio15.ph" & data$Var2 != "bio15.ph",]
data <- data[data$Var1 != "bio14.ph" & data$Var2 != "bio14.ph",]
data <- data[data$Var1 != "bio13.ph" & data$Var2 != "bio13.ph",]

# If keep bio12: get rid of bio3 (Isothermality), keep annual mean temp (1)
data <- data[data$Var1 != "bio3.ph" & data$Var2 != "bio3.ph",]
data <- data[data$Var1 != "bio10.ph" & data$Var2 != "bio10.ph",]
data <- data[data$Var1 != "bio8.ph" & data$Var2 != "bio8.ph",]

# Keep bio2: mean diurnal range, get rid of 4,5,and 7
data <- data[data$Var1 != "bio4.ph" & data$Var2 != "bio4.ph",]
data <- data[data$Var1 != "bio5.ph" & data$Var2 != "bio5.ph",]
data <- data[data$Var1 != "bio7.ph" & data$Var2 != "bio7.ph",]

#Either keep min temp of coldest month (6) or quarter (11)
data <- data[data$Var1 != "bio11.ph" & data$Var2 != "bio11.ph",]

names(biodata[,c(30,38,41,44,48)])
pairs(biodata[,c(30,38,41,44,48)])

bio.dist <- dist(biodata[,c(30,38,41,44,48)], method="manhattan") 

bio.prcomp <- prcomp(biodata[,c(30,38,41,44,48)], center = TRUE)
print(bio.prcomp)
summary(bio.prcomp)

plot.bio <- data.frame(biodata,bio.prcomp$x)

populations <- unique(plot.bio$Population)
plot.bio$Species <- "phsc"
plot.bio$Species[plot.bio$Population %in% paste(populations[c(1:3,5:7,11:15)],sep="|")] <- "phfo"
plot.bio$Species[plot.bio$Population == populations[4]] <- "phgi"


ggplot(plot.bio, aes(PC1,PC2, colour=Population))+
  geom_point()+
  theme_bw()


ggplot(plot.bio, aes(PC1,PC2, colour=Species))+
  geom_point()+
  theme_bw()

## try with princomp
bionames <- names(biodata[,c(30,38,41,44,48)])

pairs(biodata[,c(30,38,41,44,48)])
keep <- c(30,38,41,44,48)
      
ph.pca <- princomp(biodata[,keep], cor=TRUE)
summary(ph.pca)
asmi.load <- loadings(ph.pca) #1: Annual Mean Temperature, 11: Mean temp of coldest quarter, 9: Mean temp of driest quarter


plot.pca <- data.frame(ph.pca$scores, plot.bio)

ggplot(plot.pca, aes(Comp.1,Comp.2,colour = Species))+
  geom_point()+
  theme_bw()

ggplot(plot.bio, aes(bio6.ph, bio2.ph, colour = Species))+
  geom_point()+
  labs(x = "Min Temperature of Coldest Month", 
       y = "Mean Diurnal Range (Mean of monthly (max temp - min temp))")+
#  geom_polygon(aes(fill = Species), alpha = 0.3)+
  theme_bw()


ggplot(plot.bio, aes(bio1.ph, bio9.ph, colour = Species))+
  geom_point()+
  labs(x = "Annual mean temperature", y = "Mean temperature of driest quarter")+
  theme_bw()

ggplot(plot.bio, aes(bio1.ph, bio12.ph, colour = Species))+
  geom_point()+
  labs(x = "Annual mean temperature", y = "Annual Precipitation")+
  theme_bw()


# summer and winter moisture... 
ggplot(plot.bio, aes(bio18.ph, bio19.ph, colour = Species))+
  geom_point()+
  theme_bw()


ggplot(plot.bio, aes(bio11.ph, bio9.ph, colour = Species))+
  geom_point()+
  labs(x = "Mean temperature of coldest quarter", y = "Mean temperature of driest quarter")+
  theme_bw()

ggplot(plot.bio, aes(bio11.ph, bio9.ph, colour = Species))+
  geom_point()+
  labs(x = "Mean temperature of coldest quarter", y = "Mean temperature of driest quarter")+
  theme_bw()

ggplot(plot.bio, aes(bio14.ph, bio19.ph, colour = Species))+
  geom_point()+
  labs(x = "Precipitation of Driest Month", y = "Precipitation of Coldest Quarter")+
  theme_bw()

ggplot(plot.bio, aes(bio6.ph, bio19.ph, colour = Species))+
  geom_point()+
  labs(x = "Min Temperature of Coldest Month", y = "Precipitation of Coldest Quarter")+
  theme_bw()

unique(plot.bio$MUSYM)
unique(plot.bio$MUKIND)
unique(plot.bio$MUKEY)

ggplot(plot.bio, aes(MUSYM, bio12.ph, colour = Species))+
  geom_violin()+
  geom_point()+
  labs(x= "Soil Type", y = "Annual Precipitation")+
  theme_bw()


#Which are correlated? 
data[abs(data$Freq)>0.75,]

# Use daisy to combine bioclim and soil


```

